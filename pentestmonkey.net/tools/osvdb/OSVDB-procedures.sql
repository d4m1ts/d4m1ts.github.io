--------------------------------------------------------------------------------
-- OSVDB Procedures: $Revision: 1.10 $
-- © Copyright 2004 Open Security Foundation (OSF) / Open Source Vulnerability Database (OSVDB), All Rights Reserved. 
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Install:
-- Make sure the file '/usr/lib/postgresql/plpgsql.so' exists.  If not find it, and replace the path below.
-- Import the schema: psql -U postgres osvdb < OSVDB-procedures.sql
--------------------------------------------------------------------------------
CREATE FUNCTION plpgsql_call_handler () RETURNS language_handler 
    AS '$libdir/plpgsql.so', 'plpgsql_call_handler'
    LANGUAGE c;
CREATE PROCEDURAL LANGUAGE plpgsql HANDLER plpgsql_call_handler;


--------------------------------------------------------------------------------
-- Procedure: get_ext_ref_type_id
-- Description: Gets the type_id of a ext_ref_type when all that is known is the name.
-- Returns: int type_id
-- Arguments:
-- 	varchar = This would be the type_name such as 'Nessus Script ID'.
--------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION get_ext_ref_type_id (varchar) RETURNS integer AS '
	DECLARE
		typename ALIAS FOR $1;
		typeid INTEGER;
	BEGIN
		SELECT INTO typeid type_id FROM ext_ref_type WHERE LOWER(type_name) = LOWER(typename);
		IF NOT FOUND THEN
			RAISE EXCEPTION ''COULD FIND EXT_REF TYPE ID'';
		END IF;
	
	RETURN typeid;
END;
' LANGUAGE 'plpgsql';


--------------------------------------------------------------------------------
-- Procedure: new_ext_ref (osvdb_id,type_id,ref_value)
-- Description: Creates a new external reference.  Does all the dirty work.
-- Returns: boolean Sucess or Failure
-- Arguments:
-- 	int = This would be the osvdb_id such as 2010.
-- 	int = This would be the ext_ref type_id.
-- 	varchar = This would be the ref_value.
--------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION new_ext_ref (integer, integer, varchar) RETURNS boolean AS '
	DECLARE
		osvdbid ALIAS FOR $1;
		reftype ALIAS FOR $2;
		value ALIAS FOR $3;
		valueid INTEGER;
		refid INTEGER;
		oid1 INTEGER;
	BEGIN
		-- See if we have a ref_value already.  If so, get its value id, otherwise
		-- create a new one.
		SELECT INTO valueid value_id FROM ext_ref_value WHERE ref_value = value AND type_id = reftype;
		If NOT FOUND THEN
			INSERT INTO ext_ref_value (type_id,ref_value) values (reftype,value);
			IF NOT FOUND THEN
				RAISE EXCEPTION ''CAN NOT INSERT % INTO EXT_REF_VALUE'',value;
			ELSE
				GET DIAGNOSTICS oid1 = RESULT_OID;
				SELECT INTO valueid value_id FROM ext_ref_value where (oid = oid1);
			END IF;
		END IF;

		-- We should have a valueid now.
		IF valueid ISNULL THEN
			RAISE EXCEPTION ''NO AVAILABLE VALUE ID'';
		END IF;
	
		-- See if the ref already exists.
		SELECT INTO refid ref_id FROM ext_ref WHERE osvdb_id = osvdbid AND value_id = valueid and indirect = 0;
		If NOT FOUND THEN
			-- Now we can insert the ext_ref record.
			INSERT INTO ext_ref(osvdb_id,value_id) values (osvdbid, valueid);
			IF NOT FOUND THEN
				RAISE EXCEPTION ''CAN NOT INSERT % INTO EXT_REF'',valueid;
			END IF;	
		END IF;
	RETURN ''t'';
END;
' LANGUAGE 'plpgsql';


--------------------------------------------------------------------------------
-- Procedure: new_ext_ref (osvdb_id,type_id,indirect,ref_value)
-- Description: Creates a new external reference.  Does all the dirty work.
-- Returns: boolean Sucess or Failure
-- Arguments:
-- 	int = This would be the osvdb_id such as 2010.
-- 	int = This would be the ext_ref type_id.
-- 	int = This would be the ext_ref type_id.
-- 	varchar = This would be the ref_value.
--------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION new_ext_ref (integer, integer, integer, varchar) RETURNS boolean AS '
	DECLARE
		osvdbid ALIAS FOR $1;
		reftype ALIAS FOR $2;
		myindirect ALIAS FOR $3;
		value ALIAS FOR $4;
		valueid INTEGER;
		refid INTEGER;
		oid1 INTEGER;
	BEGIN
		-- See if we have a ref_value already.  If so, get its value id, otherwise
		-- create a new one.
		SELECT INTO valueid value_id FROM ext_ref_value WHERE ref_value = value AND type_id = reftype;
		If NOT FOUND THEN
			INSERT INTO ext_ref_value (type_id,ref_value) values (reftype,value);
			IF NOT FOUND THEN
				RAISE EXCEPTION ''CAN NOT INSERT % INTO EXT_REF_VALUE'',value;
			ELSE
				GET DIAGNOSTICS oid1 = RESULT_OID;
				SELECT INTO valueid value_id FROM ext_ref_value where (oid = oid1);
			END IF;
		END IF;

		-- We should have a valueid now.
		IF valueid ISNULL THEN
			RAISE EXCEPTION ''NO AVAILABLE VALUE ID'';
		END IF;
	
		-- See if the ref already exists.
		SELECT INTO refid ref_id FROM ext_ref WHERE osvdb_id = osvdbid AND value_id = valueid and indirect = myindirect;
		If NOT FOUND THEN
			-- Now we can insert the ext_ref record.
			INSERT INTO ext_ref(osvdb_id,value_id,indirect) values (osvdbid, valueid, myindirect);
			IF NOT FOUND THEN
				RAISE EXCEPTION ''CAN NOT INSERT % INTO EXT_REF'',valueid;
			END IF;	
		END IF;
	RETURN ''t'';
END;
' LANGUAGE 'plpgsql';


--------------------------------------------------------------------------------
-- Procedure: new_object (osvdb_id,vendor,base,version)
-- Description: Creates a new object.  Does all the dirty work.
-- Returns: boolean Sucess or Failure
-- Arguments:
-- 	int = This would be the osvdb_id such as 2010.
-- 	varchar = This would be the vendor, Microsoft.
-- 	varchar = This would be the product base, Exchange.
-- 	varchar = This would be the product version, 2000.
--------------------------------------------------------------------------------
DROP FUNCTION new_object (integer, varchar, varchar, varchar);
CREATE OR REPLACE FUNCTION new_object (integer, varchar, varchar, varchar, integer) RETURNS boolean AS '
	DECLARE
		osvdbid ALIAS FOR $1;
		myvendor ALIAS FOR $2;
		mybase ALIAS FOR $3;
		myversion ALIAS FOR $4;
		myaffecttypeid ALIAS FOR $5;
		corrid INTEGER;
		vendorid INTEGER;
		baseid INTEGER;
		versionid INTEGER;
		objectid INTEGER;
		oid1 INTEGER;
	BEGIN
		-- See if we have a object correlation.  If so, get its corr_id, otherwise create a new one.
		SELECT INTO corrid corr_id
		FROM object_correlation as c, object_vendor as v, object_base as b, object_version as vr
		WHERE
		c.vendor_id = v.vendor_id AND
		c.base_id = b.base_id AND
		c.version_id = vr.version_id AND
		v.vendor_name = myvendor AND
		b.base_name = mybase AND
		vr.version_name = myversion;
		If NOT FOUND THEN
			-- See if we have a vendor already.  If so, get its vendor_id, otherwise create a new one.
			SELECT INTO vendorid vendor_id FROM object_vendor WHERE vendor_name = myvendor;
			If NOT FOUND THEN
				INSERT INTO object_vendor (vendor_name) values (myvendor);
				IF NOT FOUND THEN
					RAISE EXCEPTION ''CAN NOT INSERT % INTO OBJECT_VENDOR'',myvendor;
				ELSE
					GET DIAGNOSTICS oid1 = RESULT_OID;
					SELECT INTO vendorid vendor_id FROM object_vendor where (oid = oid1);
				END IF;
			END IF;

			-- We should have a valueid now.
			IF vendorid ISNULL THEN
				RAISE EXCEPTION ''NO AVAILABLE VENDOR ID'';
			END IF;

			-- See if we have a base already.  If so, get its base_id, otherwise create a new one.
			SELECT INTO baseid base_id FROM object_base WHERE base_name = mybase;
			If NOT FOUND THEN
				INSERT INTO object_base (base_name) values (mybase);
				IF NOT FOUND THEN
					RAISE EXCEPTION ''CAN NOT INSERT % INTO OBJECT_base'',mybase;
				ELSE
					GET DIAGNOSTICS oid1 = RESULT_OID;
					SELECT INTO baseid base_id FROM object_base where (oid = oid1);
				END IF;
			END IF;

			-- We should have a valueid now.
			IF baseid ISNULL THEN
				RAISE EXCEPTION ''NO AVAILABLE base ID'';
			END IF;

			-- See if we have a version already.  If so, get its version_id, otherwise create a new one.
			SELECT INTO versionid version_id FROM object_version WHERE version_name = myversion;
			If NOT FOUND THEN
				INSERT INTO object_version (version_name) values (myversion);
				IF NOT FOUND THEN
					RAISE EXCEPTION ''CAN NOT INSERT % INTO OBJECT_version'',myversion;
				ELSE
					GET DIAGNOSTICS oid1 = RESULT_OID;
					SELECT INTO versionid version_id FROM object_version where (oid = oid1);
				END IF;
			END IF;

			-- We should have a valueid now.
			IF versionid ISNULL THEN
				RAISE EXCEPTION ''NO AVAILABLE version ID'';
			END IF;
			
			INSERT INTO object_correlation (vendor_id,base_id,version_id) values (vendorid, baseid, versionid);
			IF NOT FOUND THEN
				RAISE EXCEPTION ''CAN NOT INSERT %, %, % INTO OBJECT_CORRELATION'',vendorid, baseid, versionid;
			ELSE
				GET DIAGNOSTICS oid1 = RESULT_OID;
				SELECT INTO corrid corr_id FROM object_correlation where (oid = oid1);
			END IF;
		END IF;
		
	
		-- See if the object already exists.
		SELECT INTO objectid object_id FROM object WHERE osvdb_id = osvdbid AND corr_id = corrid;
		If NOT FOUND THEN
			-- Now we can insert the object record.
			INSERT INTO object(osvdb_id,corr_id,type_id) values (osvdbid, corrid, myaffecttypeid);
			IF NOT FOUND THEN
				RAISE EXCEPTION ''CAN NOT INSERT %,% INTO OBJECT'',osvdbid, corrid;
			END IF;	
		END IF;
	RETURN ''t'';
END;
' LANGUAGE 'plpgsql';
