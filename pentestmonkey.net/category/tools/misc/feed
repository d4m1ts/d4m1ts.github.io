<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Misc &#8211; pentestmonkey</title>
	<atom:link href="https://pentestmonkey.net/category/tools/misc/feed" rel="self" type="application/rss+xml" />
	<link>https://pentestmonkey.net</link>
	<description>Taking the monkey work out of pentesting</description>
	<lastBuildDate>Fri, 07 Oct 2011 19:47:48 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.8.3</generator>
	<item>
		<title>gateway-finder</title>
		<link>https://pentestmonkey.net/tools/gateway-finder</link>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Sun, 09 Oct 2011 16:02:38 +0000</pubDate>
				<category><![CDATA[Misc]]></category>
		<category><![CDATA[Tools]]></category>
		<category><![CDATA[discovery]]></category>
		<category><![CDATA[gateway]]></category>
		<category><![CDATA[network]]></category>
		<category><![CDATA[pentest]]></category>
		<category><![CDATA[tool]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=520</guid>

					<description><![CDATA[Gateway-finder is a scapy script that will help you determine which of the systems on the local LAN has IP forwarding enabled and which can reach the Internet. This can be useful during Internal pentests when you want to quickly check for unauthorised routes to the Internet (e.g. rogue wireless access points) or routes to other [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>Gateway-finder is a <a href="http://www.secdev.org/projects/scapy/">scapy</a> script that will help you determine which of the systems on the local LAN has IP forwarding enabled and which can reach the Internet.</p>
<p>This can be useful during Internal pentests when you want to quickly check for unauthorised routes to the Internet (e.g. rogue wireless access points) or routes to other Internal LANs.  It doesn&#8217;t perform a hugely thorough check, but it is quick at least.  It&#8217;s python, so it should be easy to modify if you need it to do something more sophisticated.</p>
<h3>Download</h3>
<p><a href="https://github.com/pentestmonkey/gateway-finder">https://github.com/pentestmonkey/gateway-finder</a></p>
<p><span class="Apple-style-span" style="color: #000000; font-size: 17px; line-height: 25px;">Overview</span></p>
<p>You give the script the IP address of a system on the Internet you&#8217;re trying to reach and it will send the following probes via each system on the local LAN:</p>
<ul>
<li>An ICMP Ping</li>
<li>A TCP SYN packet to port 80</li>
<li>An ICMP Ping with a TTL of 1</li>
<li>A TCP SYN packet to port 80 with a TTL of 1</li>
</ul>
<p>It will report separately which systems send an ICMP &#8220;TTL exceeded in transit&#8221; message back (indicating that they&#8217;re routers) and which respond to the probe (indicating that they&#8217;re gateways to the Internet).</p>
<h3>Dependencies</h3>
<p>Python and Scapy.  On Debian / Ubuntu you should just need to do this:</p>
<pre># apt-get install python-scapy</pre>
<h3>Usage</h3>
<pre># python gateway-finder.py -h
Usage: gateway-finder.py [ -I interface ] -i ip -f macs.txt

Tries to find a layer-3 gateway to the Internet.  Attempts to reach an IP
address using ICMP ping and TCP SYN to port 80 via each potential gateway
in macs.txt (ARP scan to find MACs)

Options:
  -h, --help            show this help message and exit
  -i IP, --ip=IP        Internet IP to probe
  -v, --verbose         Verbose output
  -I INTERFACE, --interface=INTERFACE
                        Network interface to use
  -f MACFILE, --macfil=MACFILE
                        File containing MAC addresses</pre>
<h3>Step 1: Run an ARP scan to identify systems on the local LAN</h3>
<p>Use your favourite ARP scanning to identify systems on the local LAN. Save the output (I use to arp.txt in the example below).</p>
<pre># arp-scan -l | tee arp.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

3 packets received by filter, 0 packets dropped by kernel
Ending arp-scan 1.6: 256 hosts scanned in 2.099 seconds (121.96 hosts/sec).  3 responded</pre>
<h3>Step 2: Run gateway-finder on the list of local systems</h3>
<p>Gateway-finder needs two bits of input from you:</p>
<ul>
<li>The MAC addresses of the potential gateways</li>
<li>The IP address of a system on the Internet (I use a google.com address in the example below):</li>
</ul>
<p>If arp.txt also contains an IP of each system on the same line as the MAC, you&#8217;ll get much nicer output.  If you need to use a different network interface, use the -I option.</p>
<pre># python gateway-finder.py -f arp.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder

[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in arp.txt
[+] 00:13:72:09:AD:76 [10.0.0.100] appears to route ICMP Ping packets to 209.85.227.99.  Received ICMP TTL Exceeded in transit response.
[+] 00:13:72:09:AD:76 [10.0.0.100] appears to route TCP packets 209.85.227.99:80.  Received ICMP TTL Exceeded in transit response.
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] Done</pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>timing-attack-checker</title>
		<link>https://pentestmonkey.net/tools/timing-attack-checker</link>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Sun, 25 Sep 2011 15:39:22 +0000</pubDate>
				<category><![CDATA[Misc]]></category>
		<category><![CDATA[Tools]]></category>
		<category><![CDATA[pentest]]></category>
		<category><![CDATA[perl]]></category>
		<category><![CDATA[tool]]></category>
		<category><![CDATA[userenumeration]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=595</guid>

					<description><![CDATA[timing-attack-checker is a simple PERL script that helps you check for timing attacks. The most common form of timing attack I&#8217;ve noticed while pentesting is that the server may take longer to respond to a valid username than to an invalid username.  This can be handy for bruteforcing a list of valid usernames.  I&#8217;ll work [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>timing-attack-checker is a simple PERL script that helps you check for timing attacks.</p>
<p>The most common form of timing attack I&#8217;ve noticed while pentesting is that the server may take longer to respond to a valid username than to an invalid username.  This can be handy for bruteforcing a list of valid usernames.  I&#8217;ll work through an example of such an attack below.</p>
<p>The script could also be used to test other types of timing attack.  It should provide microsecond-resolution timing.</p>
<p>In its simplest form, you give it two commands you want it to record the execution time of.  It will run those commands 100 times (by default), recording how long it takes.</p>
<pre style="font-family: 'Courier 10 Pitch', Courier, monospace; color: #222222; line-height: 21px; font: normal normal normal 12px/18px Consolas, Monaco, monospace; background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; background-color: #f7f7f7; margin-bottom: 24px; font-size: 15px; background-position: initial initial; background-repeat: initial initial; padding: 1.5em;">timing-attack-check.pl 'login.pl -u knownuser -p x' 'login.pl -u notexist -p x'</pre>
<p>The data is optionally saved in tab-delimited format for import into a spreadsheet.  Some raw stats are also output to help you decide if you&#8217;ve found a timing attack or not.</p>
<h3>Download</h3>
<p>Get the latest version from <a href="https://github.com/pentestmonkey/timing-attack-checker">github</a></p>
<h3>Usage</h3>
<pre>timing-attack-checker v1.0 http://pentestmonkey.net/tools/timing-attack-checker

Usage: timing-attack-check.pl [ options ] 'cmd1' 'cmd2' ['cmd3' ...]

options are:
  -n N      Number of times to run the commands
  -o file   File to write tab delimited data to

Example:
  timing-attack-check.pl 'login.pl -u knownuser -p x' 'login.pl -u notexist -p x'</pre>
<h3>Dependencies</h3>
<ul>
<li>PERL</li>
<li>Linux (because I use /dev/null for some output)</li>
<li>Time::HiRes module (probably installed by default &#8211; it is on Ubuntu 11.04)</li>
</ul>
<h3>Worked Example</h3>
<p>I set up an SSH server that only allowed logins using keys, not passwords.  I wanted to know if the server would take longer to respond to a login attempt for a valid username than for an invalid username &#8211; presumably it does less work if the username is invalid.  I load an SSH key into my ssh-agent so that the SSH client offers it to the server for each login attempt.</p>
<p>I used the following usernames for testing:</p>
<ul>
<li>&#8220;x&#8221; the name of an account that exists.  It also has an ~/.ssh/authorized_keys file</li>
<li>&#8220;y&#8221; the name of a non-existent account.</li>
<li>&#8220;z&#8221; the name of an account that exists.  It has no ~/.ssh/authorized_keys file</li>
</ul>
<p>I had an ssh-agent running that had one key loaded.  The key was not authorised to log into any account on the target system:</p>
<pre>$ ssh-keygen -f key1
$ eval `ssh-agent`
$ ssh-add key1</pre>
<p>I ran the following command to make 40 login attempts for each:</p>
<pre>$ timing-attack-checker.pl -o data.txt -n 40 'ssh x@host' 'ssh y@host' 'ssh z@host'</pre>
<p>The script output the following:</p>
<pre>[D] Running command: ssh x@host
[D] Command took 0.464256 secs
[D] Running command: ssh y@host
[D] Command took 0.115495 secs
[D] Running command: ssh z@host
[D] Command took 0.128768 secs
[D] Running command: ssh x@host
[D] Command took 0.125885 secs
[D] Running command: ssh y@host
... snip ...
=================================================
Results for: ssh x@host
Average time: 0.143035425
Minimum time: 0.10777
Maximum time: 0.464256
Standard deviation: 0.0608662980593068 (i.e. 68% of times within 1 sd, 95% within 2 sd)
Was fastest on 3 out of 40 occassions (7.5% of the time)
Was slowest on 10 out of 40 occassions (25% of the time)
=================================================
Results for: ssh y@host
Average time: 0.120723175
Minimum time: 0.095311
Maximum time: 0.206071
Standard deviation: 0.0171279751063684 (i.e. 68% of times within 1 sd, 95% within 2 sd)
Was fastest on 36 out of 40 occassions (90% of the time)
Was slowest on 3 out of 40 occassions (7.5% of the time)
=================================================
Results for: ssh z@host
Average time: 0.132942175
Minimum time: 0.114824
Maximum time: 0.154482
Standard deviation: 0.00611497853997666 (i.e. 68% of times within 1 sd, 95% within 2 sd)
Was fastest on 1 out of 40 occassions (2.5% of the time)
Was slowest on 27 out of 40 occassions (67.5% of the time)
=================================================
[+] Saving tab-delimited data to data.txt</pre>
<p>There are a lot of stats there.  Let&#8217;s discuss each in turn an see if it leads us to believe that there&#8217;s a username enumeration issue:</p>
<ul>
<li>Average time: This ranges from about 0.12 secs to 0.14 secs.  That&#8217;s a difference of more than 10%.  It&#8217;s also comparable to a standard deviation (depending which of the 3 you use).  It could be random noise caused by the laggy wireless network I ran it over.  &#8220;x&#8221; looks pretty slow.  &#8220;y&#8221; looks pretty fast.</li>
<li>Min/Max time: The min and max times for each login attempt would ideally be very similar.  We see that for some usernames the max is 2x or 4x higher than the min.  This shows we might have a choppy network connection.  Or maybe the client or server is busy.  This min/max helps to show the consistency (or otherwise) of the data collected.  Our samples aren&#8217;t particularly consistent.</li>
<li><a href="http://en.wikipedia.org/wiki/Standard_deviation">Standard Deviation</a>: How close our samples are to the average.  If themin/max of your sample set are similar and the difference between average login time for &#8220;x&#8221; and &#8220;y&#8221; (say) is more than 2 standard deviations, I think you can be pretty sure you&#8217;ve found a timing attack.  That doesn&#8217;t apply to the data we collected here (more like 1 sd).</li>
<li>Fastest/Slowest: Shows how consistently a command was the fastest/slowest in its round.  This can be useful for busy network/hosts if you can assume that all attempts will be slowed down consistently by network/host problems.  Logins were faster for &#8220;y&#8221; on 90% attempts, compared to the 33% you&#8217;d expect if no timing attack was present.  This seems quite compelling evidence that we can detect accounts that don&#8217;t exist &#8211; remember &#8220;y&#8221; doesn&#8217;t exist.</li>
</ul>
<p>So in conclusion, it seems that it would be possible to bruteforce a list of usernames that exist on the server tested.  If anyone wants to look further into this issue, I&#8217;ve included details on my config at the end of this post.</p>
<p>More generally, you&#8217;ll probably want to run only two commands, not three or more.  The option is there if you need it, though.</p>
<h3>Notes on SSH Server Config</h3>
<p>OS: Ubuntu 11.04</p>
<p>SSH Daemon: OpenSSH_5.8p1 (package: openssh-server 1:5.8p1-1ubuntu3)</p>
<p>Changes to default /etc/ssh/sshd_config:</p>
<pre>PasswordAuthentication no
Port 12345</pre>
<p>CPU: AMD Athlon(tm) 64 X2 Dual Core Processor 5000+</p>
<p>RAM: 2GB</p>
<p>Network: Wireless connection capable of around 3.5 MB/sec</p>
<p>Server was idle during testing.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Bootparamd Client for Linux</title>
		<link>https://pentestmonkey.net/tools/misc/bootparamd-client-for-linux</link>
					<comments>https://pentestmonkey.net/tools/misc/bootparamd-client-for-linux#respond</comments>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Sun, 02 Nov 2008 21:11:50 +0000</pubDate>
				<category><![CDATA[Misc]]></category>
		<category><![CDATA[bootparamd]]></category>
		<category><![CDATA[linux]]></category>
		<category><![CDATA[tool]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=117</guid>

					<description><![CDATA[See this blog post for download link and installation instructions.]]></description>
										<content:encoded><![CDATA[<p>See this <a href="http://pentestmonkey.net/blog/nis-domain-name/">blog post</a> for download link and installation instructions.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://pentestmonkey.net/tools/misc/bootparamd-client-for-linux/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Rexd Client For Linux</title>
		<link>https://pentestmonkey.net/tools/misc/rexd-client-for-linux-2</link>
					<comments>https://pentestmonkey.net/tools/misc/rexd-client-for-linux-2#respond</comments>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Sat, 01 Nov 2008 12:56:53 +0000</pubDate>
				<category><![CDATA[Misc]]></category>
		<category><![CDATA[linux]]></category>
		<category><![CDATA[rexd]]></category>
		<category><![CDATA[tool]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=116</guid>

					<description><![CDATA[Full details about &#8220;on&#8221;, the rexd client can be found on this blog post.]]></description>
										<content:encoded><![CDATA[<p>Full details about &#8220;on&#8221;, the rexd client can be found on this <a href="http://pentestmonkey.net/blog/rexd-client-for-linux/">blog post</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://pentestmonkey.net/tools/misc/rexd-client-for-linux-2/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>rsh-grind</title>
		<link>https://pentestmonkey.net/tools/misc/rsh-grind</link>
					<comments>https://pentestmonkey.net/tools/misc/rsh-grind#respond</comments>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Fri, 10 Nov 2006 22:42:52 +0000</pubDate>
				<category><![CDATA[Misc]]></category>
		<category><![CDATA[pentest]]></category>
		<category><![CDATA[rshgrind]]></category>
		<category><![CDATA[unix]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=115</guid>

					<description><![CDATA[Basically tries lots of combinations of local and remote usernames to execute commands via RSH. Download SHA1sum: f1b37abb6ad54df775c1cf194ab91fd41d607f1f MD5sum: 2ecae8730f89c697f2512181ded3842f User documentation is also available in PDF format. &#160; rsh-grind User Documentation &#160; Contents Overview Installation Usage Some Examples Assuming Remote Usernames are Same as Local Usernames What if the Local and Remote Usernames are [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>Basically tries lots of combinations of local and remote usernames to execute commands via RSH.</p>
<p><a href="/tools/rsh-grind/rsh-grind-0.9.2.tar.gz">Download</a></p>
<p>SHA1sum: f1b37abb6ad54df775c1cf194ab91fd41d607f1f</p>
<p>MD5sum: 2ecae8730f89c697f2512181ded3842f</p>
<p>User documentation is also available in <a href="/tools/rsh-grind/rsh-grind-user-docs.pdf">PDF</a> format.</p>
<p><span id="more-115"></span></p>
<p>&nbsp;</p>
<h1 align="center">rsh-grind User Documentation</h1>
<p>&nbsp;</p>
<h2><a title="SECTION00010000000000000000" name="SECTION00010000000000000000"></a> Contents</h2>
<ul>
<li><a title="tex2html11" name="tex2html11" href="rsh-grind-user-docs.html#SECTION00020000000000000000"></a>Overview</li>
<li><a title="tex2html12" name="tex2html12" href="rsh-grind-user-docs.html#SECTION00030000000000000000"></a>Installation</li>
<li><a title="tex2html13" name="tex2html13" href="rsh-grind-user-docs.html#SECTION00040000000000000000"></a>Usage</li>
<li><a title="tex2html14" name="tex2html14" href="rsh-grind-user-docs.html#SECTION00050000000000000000"></a>Some Examples
<ul>
<li><a title="tex2html15" name="tex2html15" href="rsh-grind-user-docs.html#SECTION00051000000000000000"></a>Assuming Remote Usernames are Same as Local Usernames</li>
<li><a title="tex2html16" name="tex2html16" href="rsh-grind-user-docs.html#SECTION00052000000000000000"></a>What if the Local and Remote Usernames are Different?</li>
</ul>
</li>
<li><a title="tex2html17" name="tex2html17" href="rsh-grind-user-docs.html#SECTION00060000000000000000"></a>License</li>
</ul>
<p>&nbsp;</p>
<h1><a title="SECTION00020000000000000000" name="SECTION00020000000000000000"></a>Overview</h1>
<p>rsh-grind is a tool for remotely enumerating user accounts that are able to use the Remtoe Shell (RSH) protocol. The RSH protocol requires a local and remote username to be supplied. rsh-grind simply works through all possible combinations of local and remote usernames supplied via a wordlist.</p>
<h1><a title="SECTION00030000000000000000" name="SECTION00030000000000000000"></a>Installation</h1>
<p>rsh-grind is just a stand alone PERL script, so installation is as simple as copying it to your path (e.g. /usr/local/bin). It has only been tested under Linux so far.</p>
<p>It depends on the following PERL modules which you may need to install them first:</p>
<ul>
<li>Socket</li>
<li>IO::Handle</li>
<li>IO::Select</li>
<li>IO::Socket</li>
<li>Getopt::Std</li>
<li>POSIX;</li>
</ul>
<p>If you have PERL installed, you should be able to install the modules from CPAN:</p>
<pre> # perl -MCPAN -e shell
 cpan&gt; install Getopt::Std</pre>
<h1><a title="SECTION00040000000000000000" name="SECTION00040000000000000000"></a>Usage</h1>
<p>rsh-grind simply needs to be passed a list of local users, a list of remote users and a list of target RSH servers. Here&#8217;s the usage message:</p>
<pre> Usage: rsh-grind.pl [options] ( -U username_file ) ( -f ips.txt | hostname )
        rsh-grind.pl [options] (-l local_user|-L file) | (-r remote_user|-R file) (-f ips.txt|host) 

 options are:
         -m n     Maximum number of processes (default: 10)
         -l       Local username (on the client)
         -L file  File of local usernames
         -r       Remote username (on the server)
         -R file  File or remote usernames
         -U file  File of usernames.  Each will be used as remote and local
                  user (e.g. root/root, smtp/smtp).  Permutations will not
                  be tried.
         -c cmd   Command to execute (default: id)
                  (Must be non-interactive, so don't try /bin/sh for example)
         -f file  File of target hostnames / IPs
         -t n     Wait a maximum of n seconds for reply (default: 5)
         -d       Debugging output
         -v       Verbose
         -h       This help message 

 The Remote Shell Protocol (RSH) allows remote users to execute commands
 on the server.  Authentication is based on:
 - Source IP Address
 - Remote Username
 - Local Username 

 This script can't help you with obtaining a valid source IP address, but
 it can help you try different combinations of remote and local usernames. 

 If your source IP address is in /etc/hosts.equiv, then you just need a
 valid username on the system, the remote and local usernames should be the
 same. 

 If the remote user account you're attacking has a .rhosts file like the
 following in their home directory, it doesn't matter what the local
 username is:
 IP + 

 In both of the above cases, the most efficient usage is: 

 $ rsh-grind.pl -U users.txt target 

 If the .rhosts looks like the following, though the local username must
 be "foo":
 IP foo 

 In this case you might need to try lots of permutations before you
 hit on the one that works.  The correct usage is: 

 $ rsh-grind.pl -L localusers.txt -R remoteusers.txt target 

 Output lines will be something like:
 10.0.0.1/localuser/remoteuser    _uid=101(remoteuser) gid=1(other)_ 

 Non-printable characters are sqashed to _ to fit whole response on
 one line. 

 NB: The RSH protocol requires the binding of a local privileged port, so
 you need to run this script as root.</pre>
<h1><a title="SECTION00050000000000000000" name="SECTION00050000000000000000"></a>Some Examples</h1>
<p>For the examples below we need a list of potential usernames. The following output demostrates the format for this list:</p>
<pre> $ head users.txt
 root
 bin
 daemon
 adm
 lp
 sync
 shutdown
 halt
 mail
 news</pre>
<h2><a title="SECTION00051000000000000000" name="SECTION00051000000000000000"></a> Assuming Remote Usernames are Same as Local Usernames</h2>
<p>If we assume that users of the RSH protocol will use the same username locally (i.e. where the rsh client is run) and remotely (i.e. on the server which we&#8217;re testing), we only need a single list of usernames.</p>
<pre>  $ sudo rsh-grind.pl -U users.txt 172.16.16.7
 Starting rsh-grind v0.9.2 ( http://pentestmonkey.net/tools/rsh-grind ) 

  ----------------------------------------------------------
 |                   Scan Information                       |
  ---------------------------------------------------------- 

 Processes .............. 10
 Command ................ id
 Target ................. 172.16.16.7
 Usernames file ......... users.txt
 Username count ......... 10
 Query timeout .......... 5 secs 

 ######## Scan started at Sun May  6 18:39:13 2007 #########
 172.16.16.7/bin/bin      _uid=2(bin) gid=2(bin)_
 172.16.16.7/daemon/daemon        _uid=1(daemon) gid=1(other)_
 172.16.16.7/lp/lp        _uid=71(lp) gid=8(lp)_
 172.16.16.7/adm/adm      _uid=4(adm) gid=4(adm)_
 ######## Scan completed at Sun May  6 18:39:14 2007 #########
 4 results. 

 10 queries in 1 seconds (10.0 queries / sec)</pre>
<p>Note that we have to run as root because the RSH protocol requires us to bind to ports below 1024.</p>
<p>The results show 4 pairs of local and remote users that can execute commands via RSH. This usually indicates that user have an entry like the following in their /.rhosts file:</p>
<pre> + myuser</pre>
<p>The + here means that access is allowed from any source IP address.</p>
<p>However, in this case the results are caused by the host running rsh-grind being present in /etc/hosts.equiv (not very likely in the real world, but it demonstrates what results you&#8217;d get with the small list of usernames above).</p>
<h2><a title="SECTION00052000000000000000" name="SECTION00052000000000000000"></a> What if the Local and Remote Usernames are Different?</h2>
<p>The remote username is sometimes different to the local username, e.g. a user fred might have the following in fred/.rhosts:</p>
<pre> + fbloggs</pre>
<p>This means that the remote user fbloggs would be allowed to access fred&#8217;s account from any source IP address.</p>
<p>We simply supply two lists of usernames (often, but not necessarily the same list):</p>
<pre>  $ sudo ./rsh-grind.pl -L localusers.txt -R remoteusers.txt 172.16.16.7
 Starting rsh-grind v0.9.2 ( http://pentestmonkey.net/tools/rsh-grind ) 

  ----------------------------------------------------------
 |                   Scan Information                       |
  ---------------------------------------------------------- 

 Processes .............. 10
 Command ................ id
 Target ................. 172.16.16.7
 Remote usernames file .. localusers.txt
 Local usernames file ... remoteusers.txt
 Remote username count .. 12
 Local username count ... 12
 Query timeout .......... 5 secs 

 ######## Scan started at Sun May  6 18:58:03 2007 #########
 172.16.16.7/fred/fbloggs        _uid=102(fred) gid=1(group)_
 ######## Scan completed at Sun May  6 18:58:09 2007 #########
 0 results. 

 144 queries in 6 seconds (24.0 queries / sec)</pre>
<h1><a title="SECTION00060000000000000000" name="SECTION00060000000000000000"></a>License</h1>
<p>This tool may be used for legal purposes only. Users take full responsibility for any actions performed using this tool. The author accepts no liability for damage caused by this tool. If these terms are not acceptable to you, then do not use this tool.</p>
<p>In all other respects the GPL version 2 applies:</p>
<pre> This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License version 2 as
 published by the Free Software Foundation. 

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details. 

 You should have received a copy of the GNU General Public License along
 with this program; if not, write to the Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.</pre>
]]></content:encoded>
					
					<wfw:commentRss>https://pentestmonkey.net/tools/misc/rsh-grind/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>dns-grind</title>
		<link>https://pentestmonkey.net/tools/misc/dns-grind</link>
					<comments>https://pentestmonkey.net/tools/misc/dns-grind#respond</comments>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Sun, 15 Oct 2006 14:59:53 +0000</pubDate>
				<category><![CDATA[Misc]]></category>
		<category><![CDATA[discover]]></category>
		<category><![CDATA[dns]]></category>
		<category><![CDATA[dnsgrind]]></category>
		<category><![CDATA[domain]]></category>
		<category><![CDATA[enumerate]]></category>
		<category><![CDATA[fast]]></category>
		<category><![CDATA[host]]></category>
		<category><![CDATA[hostname]]></category>
		<category><![CDATA[ip]]></category>
		<category><![CDATA[nameserver]]></category>
		<category><![CDATA[ns]]></category>
		<category><![CDATA[pentest]]></category>
		<category><![CDATA[ptr]]></category>
		<category><![CDATA[query]]></category>
		<category><![CDATA[scan]]></category>
		<category><![CDATA[tool]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=114</guid>

					<description><![CDATA[Tool for performing lots of DNS queries quickly. Download dns-grind v1.0 here. SHA1sum: db2beb7ca6caf4343f81936d78617f02b87da024 MD5sum: f145a5acf5cc53507d9be147adbe384e User documentation is also available in PDF format. &#160; dns-grind User Documentation &#160; Contents Overview Installation Usage Some Examples Bruteforcing Hostnames (A-record Lookups) Finding Registered Domains (NS-record Lookups) Finding Interesting Hosts In An IP Range (PTR-record Lookups) License &#160; Overview [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>Tool for performing lots of DNS queries quickly.</p>
<p>Download dns-grind v1.0 <a href="/tools/dns-grind/dns-grind-1.0.tar.gz">here</a>.</p>
<p>SHA1sum: db2beb7ca6caf4343f81936d78617f02b87da024</p>
<p>MD5sum: f145a5acf5cc53507d9be147adbe384e</p>
<p>User documentation is also available in <a href="/tools/dns-grind/dns-grind-user-docs.pdf">PDF</a> format.</p>
<p><span id="more-114"></span></p>
<p>&nbsp;</p>
<h1 align="center">dns-grind User Documentation</h1>
<p>&nbsp;</p>
<h2><a title="SECTION00010000000000000000" name="SECTION00010000000000000000"></a> Contents</h2>
<ul>
<li><a title="tex2html14" name="tex2html14" href="dns-grind-user-docs.html#SECTION00020000000000000000"></a>Overview</li>
<li><a title="tex2html15" name="tex2html15" href="dns-grind-user-docs.html#SECTION00030000000000000000"></a>Installation</li>
<li><a title="tex2html16" name="tex2html16" href="dns-grind-user-docs.html#SECTION00040000000000000000"></a>Usage</li>
<li><a title="tex2html17" name="tex2html17" href="dns-grind-user-docs.html#SECTION00050000000000000000"></a>Some Examples
<ul>
<li><a title="tex2html18" name="tex2html18" href="dns-grind-user-docs.html#SECTION00051000000000000000"></a>Bruteforcing Hostnames (A-record Lookups)</li>
<li><a title="tex2html19" name="tex2html19" href="dns-grind-user-docs.html#SECTION00052000000000000000"></a>Finding Registered Domains (NS-record Lookups)</li>
<li><a title="tex2html20" name="tex2html20" href="dns-grind-user-docs.html#SECTION00053000000000000000"></a>Finding Interesting Hosts In An IP Range (PTR-record Lookups)</li>
</ul>
</li>
<li><a title="tex2html21" name="tex2html21" href="dns-grind-user-docs.html#SECTION00060000000000000000"></a>License</li>
</ul>
<p>&nbsp;</p>
<h1><a title="SECTION00020000000000000000" name="SECTION00020000000000000000"></a>Overview</h1>
<p>dns-grind is a tool for performs lots of DNS queries quickly. In particular:</p>
<p>&nbsp;</p>
<ol>
<li>Bruteforce guessing of hostnames within a domain, e.g. if foobar.com doesn&#8217;t allow zone transfers, you can dns-grind to start guessing hostnames: www.foobar.com, test.foobar.com, ftp.foobar.com, etc.</li>
<li>Quickly search a list of potential domain names for those that have name servers, e.g. If you&#8217;re testing for Foobar Enterprises Ltd, might want to search a list of domain like foobar.ac, foobar.ad, etc.</li>
<li>Look for interesting hosts in a list of IP addresses by searching for PTR records &#8211; the manual equivalent of &#8216;dig -x 10.0.0.1&#8217;, &#8216;dig -x 10.0.0.2&#8217;, etc.</li>
</ol>
<p>You can instruct dns-grind to only query a specific nameserver you&#8217;re testing, or to act like a normal DNS client and use the DNS configuration from your OS.</p>
<p>You can pass it a simple list of records to look up or you can give prefixes (e.g. www, test, ftp, &#8230;) and suffixes (foobar.com, foo-bar.com). The examples below should make this a bit clearer.</p>
<h1><a title="SECTION00030000000000000000" name="SECTION00030000000000000000"></a>Installation</h1>
<p>dns-grind is just a stand alone PERL script, so installation is as simple as copying it to your path. It has only been tested under Linux so far.</p>
<p>It depends on the following PERL modules which you may need to install first:</p>
<ul>
<li>Net::DNS</li>
<li>Socket</li>
<li>IO::Handle</li>
<li>IO::Select</li>
<li>Getopt::Std</li>
</ul>
<p>If you have PERL installed, you should be able to install the modules from CPAN:</p>
<pre> # perl -MCPAN -e shell
 cpan&gt; install Net::DNS</pre>
<h1><a title="SECTION00040000000000000000" name="SECTION00040000000000000000"></a>Usage</h1>
<p>dns-grind should first be passed either a file of records to look up or a combination of prefixes and suffixes. The last parameter should be passed is the DNS query type. Only a few are supported currently.</p>
<pre> Usage: ./dns-grind.pl -f file | (( -p prefix | -P file ) | ( -s suffix | -S file )) query-type 

 query-type is one of:
         A
         NS
         MX
         PTR 

 options are:
         -m n     Maximum number of resolver processes (default: 25)
         -p       Prefix of hostname or domain
         -P file  File of hostname or domain prefixes
         -s       Suffix of hostname or domain
         -S file  File of hostname of domain suffixes
         -f       File of hostnames or domains
         -n host  Nameserver to use (default: determined by OS)
         -d       Debugging output
         -r 0|1   Use recursive queries (default: 1)
         -t n     Wait a maximum of n seconds for reply (default: 5)
         -v       Verbose
         -h       This help message</pre>
<p>Note the -m option above. Generally speaking you want at least 25 query processes running because DNS lookup can be slow if done sequentially by a low number of processes. Be aware that this tool can stress your local recursive DNS server. I&#8217;ve known the DNS service on ADSL routers to fall over if -m is set too high.</p>
<p>If you want to stress a different DNS server instead, use the -n option.</p>
<h1><a title="SECTION00050000000000000000" name="SECTION00050000000000000000"></a>Some Examples</h1>
<h2><a title="SECTION00051000000000000000" name="SECTION00051000000000000000"></a> Bruteforcing Hostnames (A-record Lookups)</h2>
<p>In the example below, we use a file of hostname prefixes (with &#8216;-P&#8217; for prefix option) and a domain, pentestmonkey.net (with the &#8216;-s&#8217; for suffix option). A single A-record is found.</p>
<pre> $ cat hostname-prefixes.txt
 alpha
 backup
 cray
 ...
 $ dns-grind.pl -P hostname-prefixes.txt -s pentestmonkey.net A
 www.pentestmonkey.net	213.165.240.11</pre>
<p>NB: Wildcard A-records may ruin your search, but you could always &#8216;grep -v wildcard-ip&#8217; as a workaround.</p>
<p>A variant of this scan would be to look for subdomains by replacing hostname-prefixes.txt with subdomain-prefixes.txt (us, uk, hq, intranet, etc.) and searching for NS-records instead of A-records.</p>
<h2><a title="SECTION00052000000000000000" name="SECTION00052000000000000000"></a> Finding Registered Domains (NS-record Lookups)</h2>
<p>The premise for this search is that only registered domains have corresponding NS records. The real-world example below shows that this method kinda works, but needs a little refinement.</p>
<p>We supply a prefix of &#8216;pentestmonkey&#8217; with the &#8216;-p&#8217; option, and a file of potential suffixes <a title="tex2html1" name="tex2html1" href="#foot25"></a><sup>1</sup> with the -S option. Note the captial letter in -S or -P to signify a file option, and lowercase -p or -s for a single prefix or suffix<a title="tex2html2" name="tex2html2" href="#foot26"></a><sup>2</sup>.</p>
<pre> $ cat tlds.txt
 ac
 ad
 ae
 ... 

 $ dns-grind.pl -p pentestmonkey -S tlds.txt  ns
 pentestmonkey.mp        ns1.sdcdns.mp,ns2.sdcdns.mp
 pentestmonkey.vg
 pentestmonkey.sh        ns1c.nic.ac,ns2c.nic.ac
 pentestmonkey.net       ns0.nl.ev6.net,ns0.uk.ev6.net
 pentestmonkey.com       ns0.nl.ev6.net,ns0.uk.ev6.net,ns1.uk.ev6.net
 pentestmonkey.ac        ns1c.nic.ac,ns2c.nic.ac
 pentestmonkey.io        ns1c.nic.ac,ns2c.nic.ac
 pentestmonkey.tm        ns1c.nic.ac,ns2c.nic.ac
 pentestmonkey.org       ns0.uk.ev6.net,ns1.uk.ev6.net,ns0.nl.ev6.net</pre>
<p>After a bit of further investigation we find that there&#8217;s a wildcard NS record for any domain ending in .mp, .sh, .ac, .io, or .tm. These results are effectively false-positives. As is .vg for which a CNAME is returned when we look up the NS record.</p>
<p>The only registered domains with a prefix of &#8216;pentestmonkey&#8217; are therefore .com, .net and .org.</p>
<h2><a title="SECTION00053000000000000000" name="SECTION00053000000000000000"></a> Finding Interesting Hosts In An IP Range (PTR-record Lookups)</h2>
<p>Simply supply a list of IP addresses with the -f option. Below we use the genip<a title="tex2html3" name="tex2html3" href="#foot30"></a><sup>3</sup>tool to generate a list of IPs first.</p>
<pre> $ genip 10.0.0.0/24 &gt; ips.txt
 $ dns-grind.pl -f ips.txt PTR
 10.0.0.10	www.example.com
 10.0.0.99	manager.example.com</pre>
<h1><a title="SECTION00060000000000000000" name="SECTION00060000000000000000"></a>License</h1>
<p>This tool may be used for legal purposes only. Users take full responsibility for any actions performed using this tool. The author accepts no liability for damage caused by this tool. If these terms are not acceptable to you, then do not use this tool.</p>
<p>In all other respects the GPL version 2 applies:</p>
<pre> This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License version 2 as
 published by the Free Software Foundation. 

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details. 

 You should have received a copy of the GNU General Public License along
 with this program; if not, write to the Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.</pre>
]]></content:encoded>
					
					<wfw:commentRss>https://pentestmonkey.net/tools/misc/dns-grind/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>yapscan</title>
		<link>https://pentestmonkey.net/tools/misc/yapscan</link>
					<comments>https://pentestmonkey.net/tools/misc/yapscan#respond</comments>
		
		<dc:creator><![CDATA[pentestmonkey]]></dc:creator>
		<pubDate>Thu, 14 Sep 2006 23:35:42 +0000</pubDate>
				<category><![CDATA[Misc]]></category>
		<category><![CDATA[pentest]]></category>
		<category><![CDATA[Tools]]></category>
		<category><![CDATA[yapscan]]></category>
		<guid isPermaLink="false">http://pentestmonkey.net/?p=113</guid>

					<description><![CDATA[TCP Half-open port scanner / fast ICMP scanner. Some limited support for UDP scans too. It&#8217;s beta, but still kinda useful. Download Yapscan v0.7.4-beta as tar.gz. Recent changes are detailed in the CHANGELOG. Update: You&#8217;re better off using the SVN copy on google code.  It&#8217;s more up to date. MD5 and SHA1 checksums are the [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>TCP Half-open port scanner / fast ICMP scanner. Some limited support for UDP scans too. It&#8217;s beta, but still kinda useful.</p>
<p>Download Yapscan v0.7.4-beta as <a href="/tools/yapscan/yapscan-0.7.4-beta.tar.gz">tar.gz</a>. Recent changes are detailed in the <a href="/tools/yapscan/CHANGELOG">CHANGELOG.</a></p>
<p>Update: You&#8217;re better off using the <a href="http://code.google.com/p/yapscan/source/checkout">SVN copy on google code</a>.  It&#8217;s more up to date.</p>
<p>MD5 and SHA1 checksums are the packages can be downloaded.  They&#8217;re based on the package name (below v.v.v represents the version, e.g. 0.6.1):<br />
http://pentestmonkey.net/tools/yapscan/yapscan-v.v.v-beta.tar.gz.md5<br />
http://pentestmonkey.net/tools/yapscan/yapscan-v.v.v-beta.tar.gz.sha1</p>
<p>User documentation is also available in <a href="/tools/yapscan/yapscan-user-docs.pdf">PDF</a> format.</p>
<p><span id="more-113"></span></p>
<p>&nbsp;</p>
<h1 align="center">Yapscan User Documentation</h1>
<p>&nbsp;</p>
<h2><a title="SECTION00010000000000000000" name="SECTION00010000000000000000"></a> Contents</h2>
<ul>
<li><a title="tex2html31" name="tex2html31" href="#SECTION00020000000000000000"></a>Overview</li>
<li><a title="tex2html32" name="tex2html32" href="#SECTION00030000000000000000"></a>License</li>
<li><a title="tex2html33" name="tex2html33" href="#SECTION00040000000000000000"></a>Installation
<ul>
<li><a title="tex2html34" name="tex2html34" href="#SECTION00041000000000000000"></a>Quick Start</li>
<li><a title="tex2html35" name="tex2html35" href="#SECTION00042000000000000000"></a>Trouble Shooting</li>
<li><a title="tex2html36" name="tex2html36" href="#SECTION00043000000000000000"></a>Workaround For Missing OpenSSL Libraries</li>
</ul>
</li>
<li><a title="tex2html37" name="tex2html37" href="#SECTION00050000000000000000"></a>Features
<ul>
<li><a title="tex2html38" name="tex2html38" href="#SECTION00051000000000000000"></a>TCP SYN Scanning</li>
<li><a title="tex2html39" name="tex2html39" href="#SECTION00052000000000000000"></a>(Limited) UDP Port Scanning</li>
<li><a title="tex2html40" name="tex2html40" href="#SECTION00053000000000000000"></a>ICMP Scanning</li>
<li><a title="tex2html41" name="tex2html41" href="#SECTION00054000000000000000"></a>Scanning Speed</li>
<li><a title="tex2html42" name="tex2html42" href="#SECTION00055000000000000000"></a>Retries</li>
</ul>
</li>
<li><a title="tex2html43" name="tex2html43" href="#SECTION00060000000000000000"></a>Yapscan Output
<ul>
<li><a title="tex2html44" name="tex2html44" href="#SECTION00061000000000000000"></a>Scan Information</li>
<li><a title="tex2html45" name="tex2html45" href="#SECTION00062000000000000000"></a>Scan Start and End Times</li>
<li><a title="tex2html46" name="tex2html46" href="#SECTION00063000000000000000"></a>TCP Scanning</li>
<li><a title="tex2html47" name="tex2html47" href="#SECTION00064000000000000000"></a>ICMP Scanning</li>
</ul>
</li>
<li><a title="tex2html48" name="tex2html48" href="#SECTION00070000000000000000"></a>Limitations
<ul>
<li><a title="tex2html49" name="tex2html49" href="#SECTION00071000000000000000"></a>Memory-hungry</li>
<li><a title="tex2html50" name="tex2html50" href="#SECTION00072000000000000000"></a>Replies from different IPs</li>
</ul>
</li>
<li><a title="tex2html51" name="tex2html51" href="#SECTION00080000000000000000"></a>Why write Yet Another Port Scanner?</li>
<li><a title="tex2html52" name="tex2html52" href="#SECTION00090000000000000000"></a>Credit</li>
</ul>
<p>&nbsp;</p>
<h1><a title="SECTION00020000000000000000" name="SECTION00020000000000000000"></a>Overview</h1>
<p>Yapscan is primarily a half-open TCP port scanner and ICMP scanner. It has a few other uses too. These are explained more fully in the &#8220;Features&#8221; section below.</p>
<h1><a title="SECTION00030000000000000000" name="SECTION00030000000000000000"></a>License</h1>
<p>This tool may be used for legal purposes only. Users take full responsibility for any actions performed using this tool. The author accepts no liability for damage caused by this tool. If these terms are not acceptable to you, then do not use this tool.</p>
<p>In all other respects the GPL version 2 applies:</p>
<pre> This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License version 2 as
 published by the Free Software Foundation. 

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details. 

 You should have received a copy of the GNU General Public License along
 with this program; if not, write to the Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.</pre>
<h1><a title="SECTION00040000000000000000" name="SECTION00040000000000000000"></a>Installation</h1>
<h2><a title="SECTION00041000000000000000" name="SECTION00041000000000000000"></a> Quick Start</h2>
<p>If you have a Linux system, with any luck the installation will just work. Other systems are not supported at this time.</p>
<p>Firstly, go and download the latest tarball of yapscan from http://pentestmonkey.net if you haven&#8217;t already.</p>
<pre> su -
 cd /usr/local/src
 tar xfz yapscan-X.Y.tar.gz
 cd yapscan-X.Y
 make
 make install</pre>
<h2><a title="SECTION00042000000000000000" name="SECTION00042000000000000000"></a> Trouble Shooting</h2>
<p>Yapscan should install on most flavours of Linux. I&#8217;ve tried it on Gentoo using gcc v3.3.x, 3.4.x and 4.1.x (both x86 and AMD64) and Debian &#8220;Testing&#8221; using gcc-4.1.2. I think I&#8217;ve ironed out any bugs which stop compilation. That said, you&#8217;re reading this section, so I guess something went wrong&#8230;</p>
<p>Any installation problems will be results of either missing header files, missing libraries or my dodgy code. Whatever the cause I&#8217;d like to make sure that this section covers the problem (or that I fix any dodgy code). If you run into problems and the notes below don&#8217;t help, please email me at the address on the first page.</p>
<p>Yapscan depends on libpcap to capture reply packets, so firstly make sure you&#8217;ve installed it. On Gentoo the package is called &#8220;libpcap&#8221; on Debian it&#8217;s &#8220;libpcap-dev&#8221;(the version that includes the header files).</p>
<p>Linking against OpenSSL is also recommended because it speeds up scanning. Installation is still possible if you can&#8217;t install OpenSSL &#8211; there&#8217;s a workaround below. The OpenSSL package on Gentoo is called &#8220;openssl&#8221;, on Debian it&#8217;s &#8220;openssl-dev&#8221;.</p>
<p>If installing these dependencies doesn&#8217;t solve your problem, mail me and I&#8217;ll try to help.</p>
<h2><a title="SECTION00043000000000000000" name="SECTION00043000000000000000"></a> Workaround For Missing OpenSSL Libraries</h2>
<p>Open up &#8220;Makefile&#8221; in you favourite text editor and change this bit:</p>
<pre> # OpenSSL's MD5 library speeds up scanning.  If you have openssl installed, do this:
 DEFINES=-DHAVE_LIBCRYPTO ${DEBUGDEFINES}
 LDLIBS=-lpcap -lcrypto 

 # Otherwise do this:
 # DEFINES=${DEBUGDEFINES}
 # LDLIBS=-lpcap</pre>
<p>to:</p>
<pre> # OpenSSL's MD5 library speeds up scanning.  If you have openssl installed, do this:
 # DEFINES=-DHAVE_LIBCRYPTO ${DEBUGDEFINES}
 # LDLIBS=-lpcap -lcrypto 

 # Otherwise do this:
 DEFINES=${DEBUGDEFINES}
 LDLIBS=-lpcap</pre>
<p>The try to compile again:</p>
<pre> make clean
 make
 make install</pre>
<h1><a title="SECTION00050000000000000000" name="SECTION00050000000000000000"></a>Features</h1>
<h2><a title="SECTION00051000000000000000" name="SECTION00051000000000000000"></a> TCP SYN Scanning</h2>
<p>Also known as half-open scanning.</p>
<p>On an internal network you probably just want to see the open ports. Here are some example of how to specify hosts and ports:</p>
<pre> # yapscan -sS 192.168.0.1-254 -p 1-1024
 # yapscan -sS 10.0.0.1-10.0.255.255 -p 21,22,23,53,80,139,445,3389
 # yapscan -sS 172.16.0.0/16 -p 80
 # yapscan -sS -f targets-ips.txt -p 4444</pre>
<p>From an external network, you might also want to see the closed ports (-c):</p>
<pre> # yapscan -sS www.example.com -p 1-65535 -c</pre>
<p>You can scan just the common ports (using a portlist derived from nmap):</p>
<pre> # yapscan -sS 127.0.0.1 -i lo -P common</pre>
<p>(supported keywords are based on filenames what ship with yapscan. As of v0.5.5-beta there is: all, known, common, database)</p>
<p>Note that we needed to specify the different interface to listen for replies on (default is eth0).</p>
<p>Specify ports using names as well as numbers (from /etc/services):</p>
<pre> # yapscan -sS router -i eth1 -p telnet,80,443,ssh,6000-6063</pre>
<p>Or specify your own port list (1 port per line):</p>
<pre> # yapscan -sS -f mytargets.txt -P myports.txt</pre>
<p>You can do &#8220;-p -&#8221; like in nmap too if you want to scan 1-65535:</p>
<pre> # yapscan -sS -f mytargets.txt -p -</pre>
<p>I&#8217;ve also implemented the exotic type of scans like Xmas tree, null, etc. These aren&#8217;t particularly well tested as of v0.5.5-beta. See the help message for more info: yapscan -h</p>
<p>Also see &#8220;Scanning Speed&#8221; and &#8220;Retries&#8221; near the end of this section. In particular, make sure you specify a low speed for remote testing (e.g. -b 32k).</p>
<h2><a title="SECTION00052000000000000000" name="SECTION00052000000000000000"></a> (Limited) UDP Port Scanning</h2>
<p>This scan mode is designed to answer the question &#8220;Does host X have any closed UDP ports?&#8221; i.e. does it reply with an ICMP Port Unreachable for probes sent to one or more of its UDP ports.</p>
<p>This type of scan will (unfortunately) not tell you all the open UDP ports.</p>
<p>I use this mainly for scanning Firewalled hosts which I&#8217;m pretty sure won&#8217;t have any closed UDP ports.</p>
<p>Yapscan sends empty UDP packets to a range of ports at a steady (usually quite fast) rate. It will report any ICMP port unreachable messages it receives.</p>
<p>If you receive no replies then you know there are no closed UDP ports.</p>
<pre> # yapscan -su router -i eth1 -p 1-65535</pre>
<p><strong>IMPORTANT NOTE:</strong> If you receive 1 or more ICMP port unreachable error messages, you cannot infer that these are the only close ports. Yapscan does not back-off intelligently like nmap, so a host which limits that rate at which it sends ICMP errors, will (falsely) appear to have less ports open.</p>
<h2><a title="SECTION00053000000000000000" name="SECTION00053000000000000000"></a> ICMP Scanning</h2>
<p>Yapscan can perform the following type of ICMP sweeps:</p>
<ul>
<li>Echo Request</li>
<li>Timestamp Request</li>
<li>Addressmask Request</li>
<li>Information Request</li>
</ul>
<p>You can perform 1 or more types of scan at once:</p>
<pre> # yapscan -sI 10.0.0.0/16 -t echo
 # yapscan -sI 10.0.0.0/16 -t echo -t addr
 # yapscan -sI 10.0.0.0/16 -t info
 # yapscan -sI 10.0.0.0/16 -t time
 # yapscan -sI 10.0.0.0/16 -t -</pre>
<p>The last example will scan all supported ICMP types.</p>
<p>As of v0.5.5-beta yapscan is also able to send Router Solicitations, but it won&#8217;t report replies, so this 5th type isn&#8217;t much use at present.</p>
<h2><a title="SECTION00054000000000000000" name="SECTION00054000000000000000"></a> Scanning Speed</h2>
<p>Yapscan scans at a steady (and configurable) speed. You can get an ETA on you scan by pressing Enter during the scan.</p>
<p>As of v0.4.9-beta yapscan will never underestimate the remaining scan time, though it can over estimate it under certain conditions.</p>
<p>By default yapscan scans at 1000000 Bits / Second. Unless you have a fast link / understanding clients or both I suggest you only use the default for LAN testing. I wouldn&#8217;t recommend going much about 2Mb/s for reliability / DoS reasons, but you can try it if you like:</p>
<pre> # yapscan -sS -p - 192.168.0.1-14 -b 4M</pre>
<p>WAN testing&#8217;s probably better done at a more sociable speed like 64Kb/s:</p>
<pre> # yapscan -sS -p - www.example.com -b 64k</pre>
<p>Obviously, if the scan rate is set higher than either your upstream bandwidth or the client&#8217;s downstream bandwidth, packets will be dropped and the reliability of the scan reduced.</p>
<h2><a title="SECTION00055000000000000000" name="SECTION00055000000000000000"></a> Retries</h2>
<p>Reliability is obviously paramount during pentests, so the use of retries is encouraged. ICMP scans do 2 retries by default (a total of 3 tries in all). TCP and UDP only do 1.</p>
<p>For an even more reliable ICMP scan you could do:</p>
<pre> # yapscan -sI -r 5 myhost -t -</pre>
<p>A TCP scan would be made more reliable by:</p>
<pre> # yapscan -sS -r 2 myhost -p -</pre>
<h1><a title="SECTION00060000000000000000" name="SECTION00060000000000000000"></a>Yapscan Output</h1>
<h2><a title="SECTION00061000000000000000" name="SECTION00061000000000000000"></a> Scan Information</h2>
<p>The first thing you see when you run yapscan is the &#8220;Scan Information&#8221; section. This section summarises the parameters for the scan. I included this basically so that when I looked back over my scan results I had some idea of what I&#8217;d scanned.</p>
<pre>  ----------------------------------------------------------
 |                   Scan Information                       |
  ----------------------------------------------------------
 Target count: ...... 1
 Interface: ......... lo
 Bandwidth limit: ... 1000000 bits/sec
 Source address: .... 127.0.0.1
 RTT: ............... 0.950000 secs
 Tries: ............. 3
 ICMP Probe Types: .. 8 (ECHO_REQUEST)</pre>
<p>The output looks slightly different for the various scan types.</p>
<h2><a title="SECTION00062000000000000000" name="SECTION00062000000000000000"></a> Scan Start and End Times</h2>
<p>The start and end times are included to provide a record of when the scan was done.</p>
<pre> ######## Scan started at 2006-10-22 20:37:26 +0000 #########
 ...
 ####### Scan completed at 2006-10-22 20:37:27 +0000 #########</pre>
<h2><a title="SECTION00063000000000000000" name="SECTION00063000000000000000"></a> TCP Scanning</h2>
<p>Below is the output of a fictional TCP SYN scan run with the -c option to show closed ports as well as open ones (so I can illustrate some fields not always shown in the output).</p>
<pre> 10.0.1.1:25   smtp  Len=46 TTL=19 IPID=0 FLAGS=_AR_____ SEQ=0x00000000 ACK=0x4e5d5003 WIN=0 DATA="rctcpoy"
 10.0.2.2:80    http  Len=46 TTL=21 IPID=0 FLAGS=_AR_____ SEQ=0x00000000 ACK=0x0b712500 WIN=0 DATA="rctcpo"
 10.0.3.3:53    domain  Len=44 TTL=64 IPID=0 FLAGS=SA______ SEQ=0xd1183250 ACK=0x17f67482 WIN=32792
 10.0.4.4:1999     tcp-id-port     Len=40 TTL=59 IPID=43634 FLAGS=_AR____C SEQ=0x00000000
 ACK=0x28f45290 WIN=0
 10.0.5.5:1999      tcp-id-port     Len=45 TTL=244 IPID=22340 FLAGS=_AR_____ SEQ=0x00000000
 ACK=0xab7e84c2 WIN=0 DATA="cisco"</pre>
<p>We&#8217;ll use the first reply to quickly cover most of the generic fields, then we&#8217;ll look at some of the interesting ones.</p>
<table border="1" cellpadding="3">
<tbody>
<tr>
<th align="left"><strong>Field</strong></th>
<th align="left" valign="top" width="198"><strong>Meaning</strong></th>
</tr>
<tr>
<td align="left">10.0.3.3</td>
<td align="left" valign="top" width="198">IP Address reply came from</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left" valign="top" width="198">TCP Port number reply came from</td>
</tr>
<tr>
<td align="left">smtp</td>
<td align="left" valign="top" width="198">Name of port (from /etc/services)</td>
</tr>
<tr>
<td align="left">Len=46</td>
<td align="left" valign="top" width="198">Length of packet (IP header + TCP header + data)</td>
</tr>
<tr>
<td align="left">TTL=19</td>
<td align="left" valign="top" width="198">Time-to-Live of reply packet</td>
</tr>
<tr>
<td align="left">IPID=0</td>
<td align="left" valign="top" width="198">IP ID on reply</td>
</tr>
<tr>
<td align="left">FLAGS=_AR_____</td>
<td align="left" valign="top" width="198">TCP Flags: S=SYN, A=ACK, R=RST, F=FIN, P=PSH, U=URG, E=ECN, C=CWR</td>
</tr>
<tr>
<td align="left">SEQ=0x00000000</td>
<td align="left" valign="top" width="198">TCP Sequence number</td>
</tr>
<tr>
<td align="left">ACK=0x4e5d5003</td>
<td align="left" valign="top" width="198">TCP Acknowledgement number</td>
</tr>
<tr>
<td align="left">WIN=0</td>
<td align="left" valign="top" width="198">TCP Windows size</td>
</tr>
<tr>
<td align="left">DATA=&#8220;rctcpoy&#8221;</td>
<td align="left" valign="top" width="198">Data carried by TCP packet (if any)</td>
</tr>
</tbody>
</table>
<p>We see that IP address 10.0.3.3 has TCP port 53 open (note the SYN and ACK flags are set on the response). The rest of the packets indicate closed ports (the RST flag is set).</p>
<p>Some of the RST packets have data attached. This is much more rare than I&#8217;ve made it seem in this example, but it&#8217;s an interesting feaure of yapscan, so worth some discussion.</p>
<p>According to http://www.sonicwall.com/support/pdfs/technotes/SonicOS_TCP_RST.pdf, the string &#8220;rctcpo&#8221; for 10.0.2.2 seems to indicate that the host is protected by a Sonicwall Firewall. Presumably 10.0.3.3 is similarly protected, but I haven&#8217;t tracked down any documentation as to the exact meaning of &#8220;rctcpoy&#8221;.</p>
<p>The data &#8220;cisco&#8221; is return on the response from 10.0.5.5. This is a feature of certain older version of Cisco IOS. The feature is documented as a fingerprinting vulnerability at http://cve.mitre.org/cgi-bin/cvename.cgi?name=1999-0453.</p>
<p>Finally, note that the packet from 10.0.4.4 has the TCP C flag set. This is the Congestion Window Reduced flag, a relatively new TCP option.</p>
<p>NB: There is currently no support for displaying IP options or TCP options.</p>
<h2><a title="SECTION00064000000000000000" name="SECTION00064000000000000000"></a> ICMP Scanning</h2>
<p>The output below shows pretty much all of the various fields you&#8217;re likely to come across when running ICMP sweeps with yapscan:</p>
<pre> 10.0.1.1:18/0 [ADDRESS_REPLY] Len=32 TTL=56 IPID=10224 ID=10406 SEQ=13643 MASK=255.255.254.0
 10.0.2.2:18/0 [ADDRESS_REPLY] Len=32 TTL=248 IPID=15111 ID=4233 SEQ=39939 MASK=255.255.255.252
 10.0.3.3:14/0 [TIMESTAMP_REPLY] Len=40 TTL=249 IPID=31174 ID=2463 SEQ=52706 orig=0x040f417e
 recv=0x83ecf893 xmit=0x83ecf893 std=0 end=1
 10.0.4.4:14/0 [TIMESTAMP_REPLY] Len=40 TTL=128 IPID=1617 ID=2182 SEQ=92 orig=0x041ae462
 recv=0x9cdc1a04 xmit=0x9cdc1a04 std=1 end=0 xmit-time=19:07:49.276 delta=-1.984
 10.0.5.5:14/0 [TIMESTAMP_REPLY] Len=40 TTL=240 IPID=10035 ID=6689 SEQ=42152 orig=0x040f40aa
 recv=0x04131907 xmit=0x04131907 std=1 end=1 xmit-time=18:59:20.455 delta=252.000
 10.0.6.6:16/0 [INFO_REPLY] Len=28 TTL=247 IPID=48924 ID=3706 SEQ=64144
 10.0.7.7:16/0 [INFO_REPLY] Len=28 TTL=243 IPID=64889 ID=10674 SEQ=17306
 10.0.8.8:0/0 [ECHO_REPLY] Len=28 TTL=128 IPID=1616 ID=21821 SEQ=92</pre>
<h3><a title="SECTION00064100000000000000" name="SECTION00064100000000000000"></a> Generic ICMP Fields</h3>
<p>The following fields are common to all ICMP results:</p>
<table border="1" cellpadding="3">
<tbody>
<tr>
<th align="left"><strong>Field</strong></th>
<th align="left" valign="top" width="198"><strong>Meaning</strong></th>
</tr>
<tr>
<td align="left">10.0.1.1</td>
<td align="left" valign="top" width="198">IP Address reply came from</td>
</tr>
<tr>
<td align="left">18/0</td>
<td align="left" valign="top" width="198">The ICMP Type of the reply was 18. The ICMP Code was 0.</td>
</tr>
<tr>
<td align="left">[ADDRESS_REPLY]</td>
<td align="left" valign="top" width="198">A human readable form for the ICMP Type. Type 18 is Address Mask Reply</td>
</tr>
<tr>
<td align="left">Len=32</td>
<td align="left" valign="top" width="198">Length of packet (IP header + ICMP header + data)</td>
</tr>
<tr>
<td align="left">TTL=56</td>
<td align="left" valign="top" width="198">Time-to-Live of reply packet</td>
</tr>
<tr>
<td align="left">IPID=10224</td>
<td align="left" valign="top" width="198">IP ID on reply</td>
</tr>
<tr>
<td align="left">SEQ=13643</td>
<td align="left" valign="top" width="198">ICMP Sequence number</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h3><a title="SECTION00064200000000000000" name="SECTION00064200000000000000"></a> ICMP Address Mask Fields</h3>
<p>A single field is unique to ICMP Address Mask scans:</p>
<table border="1" cellpadding="3">
<tbody>
<tr>
<th align="left"><strong>Field</strong></th>
<th align="left" valign="top" width="198"><strong>Meaning</strong></th>
</tr>
<tr>
<td align="left">MASK=255.255.254.0</td>
<td align="left" valign="top" width="198">The netmask of the corresponding IP is 255.255.254.0</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h3><a title="SECTION00064300000000000000" name="SECTION00064300000000000000"></a> ICMP Timestamp Fields</h3>
<p>Yapscan will tell you if the remote system clock is accurate if the timestamp supplied is in a standard format. It manages this even the remote system has a broken IP stack which uses the wrong endianness for the timestamp fields.</p>
<table border="1" cellpadding="3">
<tbody>
<tr>
<th align="left"><strong>Field</strong></th>
<th align="left" valign="top" width="198"><strong>Meaning</strong></th>
</tr>
<tr>
<td align="left">orig=0x040f417e</td>
<td align="left" valign="top" width="198">Originator timestamp in hex</td>
</tr>
<tr>
<td align="left">recv=0x83ecf893</td>
<td align="left" valign="top" width="198">Received Timestamp in hex</td>
</tr>
<tr>
<td align="left">xmit=0x83ecf893</td>
<td align="left" valign="top" width="198">Transmit Timestamp in hex</td>
</tr>
<tr>
<td align="left">std=0</td>
<td align="left" valign="top" width="198">Do the timestamp fileds contain the number of milliseconds since midnight UTC as suggested by RFC 792?</td>
</tr>
<tr>
<td align="left">end=1</td>
<td align="left" valign="top" width="198">Does the endianness of the xmit field appear to be correct (big endian AKA network byte order)? Most versions of Windows use the wrong endianness in this field.</td>
</tr>
<tr>
<td align="left">xmit-time=19:07:49.276</td>
<td align="left" valign="top" width="198">Only displayed if std=1. A human readable representation of the xmit field. If the endianness of xmit was wrong, it is reverse before being converted to human readable format, so Yapscan will display meaningful timestamps even for Windows systems.</td>
</tr>
<tr>
<td align="left">delta=-1.984</td>
<td align="left" valign="top" width="198">Only displayed if std=1. The number of seconds ahead of UTC the remote system&#8217;s clock is. (UTC according to your system clock).</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h3><a title="SECTION00064400000000000000" name="SECTION00064400000000000000"></a> ICMP Echo Fields</h3>
<p>See Generic ICMP Fields section above. No additional fields are available for Echo replies.</p>
<p>&nbsp;</p>
<h3><a title="SECTION00064500000000000000" name="SECTION00064500000000000000"></a> ICMP Information Fields</h3>
<p>See Generic ICMP Fields section above. No additional fields are available for Info replies.</p>
<h1><a title="SECTION00070000000000000000" name="SECTION00070000000000000000"></a>Limitations</h1>
<h2><a title="SECTION00071000000000000000" name="SECTION00071000000000000000"></a> Memory-hungry</h2>
<p>Yapscan implements retries by keeping a list of hosts and ports to be scanned in memory. This has the side effect of using an awful lot of memory on large scans: 770MB for 65535 ports on 256 hosts</p>
<p>This a pretty big problem. I really need to break the scan into chunks.</p>
<h2><a title="SECTION00072000000000000000" name="SECTION00072000000000000000"></a> Replies from different IPs</h2>
<p>If you send a packet to an address which elicits a reply from a different IP address (e.g. you ping 192.168.0.255 and get a reply from 192.168.0.5) the reply will not be reported by yapscan.</p>
<p>This is because all cookies carry a &#8220;cookie&#8221; of some description which is derived from the source and destination IP of the original probe. Yapscan will inspect the reply and ensure that cookie contained within it is derived from the source and destination IP. If an unexpected IP replies yapscan will assume that the traffic is not a response to a probe.</p>
<h1><a title="SECTION00080000000000000000" name="SECTION00080000000000000000"></a>Why write Yet Another Port Scanner?</h1>
<p>When I started writing yapscan I wanted to:</p>
<ol>
<li>Learn some C++</li>
<li>Write some generic classes that handle all the mundane parts of port scanning (like hostlist traversal, retries, bandwidth usage).</li>
</ol>
<p>The idea being that next time I needed to write a scanner (whether it be ARP, IPv6, DNS server-finder, mass DoS payload deliverer, etc.) I&#8217;d be able to quickly code up the probe, define how to parse responses and the generic classes would take care of the rest.</p>
<p>Alas, my eyes were too big for my belly and I&#8217;ve ended up with yet another IPv4 port scanner.</p>
<p>Maybe I&#8217;ll achieve my original goal someday, but as of today I&#8217;m still some way off.</p>
<p>That said, I do find yapscan useful during most pentests, so I thought I&#8217;d submit it back to he community in hope that others would too.</p>
<h1><a title="SECTION00090000000000000000" name="SECTION00090000000000000000"></a>Credit</h1>
<p>Much inspiration (and even small amounts of code) as been drawn from other tools. It&#8217;s only right that I pay my dues&#8230;</p>
<p>&nbsp;</p>
<dl>
<dt><strong>synscan</strong></dt>
<dd><em>http://bindshell.net/tools/synscan</em>The fastest half-open portscanner that I&#8217;m aware of. I borrowed the code for determining link-layer header lengths from synscan. </dd>
<dt><strong>nmap</strong></dt>
<dd><em>http://insecure.org/nmap</em>The most reliable portscanner I&#8217;m aware of. I use nmap during every pentest. Most of yapscan&#8217;s options are designed to be intuitive for nmap users. </dd>
<dt><strong>ike-scan</strong></dt>
<dd><em>http://www.nta-monitor.com/tools/ike-scan</em>Hostlist structures and retries are heavily inspired by ike-scan. </dd>
<dt><strong>hping2</strong></dt>
<dd><em>http://www.hping.org</em>The output format is loosley based on hping2&#8217;s. </dd>
<dt><strong>scanrand</strong></dt>
<dd><em>http://www.doxpara.com/paketto</em>I love the Inverse SYN Cookies idea. Very simple method to determine if replies on the wire are meant for your scanner or some other app. </dd>
</dl>
]]></content:encoded>
					
					<wfw:commentRss>https://pentestmonkey.net/tools/misc/yapscan/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
